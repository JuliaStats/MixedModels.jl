
"""
    MultimembershipReMat{T,S} <: AbstractMatrix{T}

A section of a model matrix generated by a random-effects term that may not conform
to the usual patterns of sparsity in single-membership random-effects terms

# Fields
- `trm`: the grouping factor as a `StatsModels.CategoricalTerm`
- `levels`: the levels of the grouping factor
- `cnames`: the column names of the model matrix generated by the left-hand side of the term
- `z`: transpose of the model matrix generated by the left-hand side of the term
- `wtz`: a weighted copy of `z` (`z` and `wtz` are the same object for unweighted cases)
- `λ`: a `LowerTriangular` matrix of size `S×S`
- `inds`: a `Vector{Int}` of linear indices of the potential nonzeros in `λ`
- `adjA`: the adjoint of the matrix as a `SparseMatrixCSC{T}`
- `scratch`: a Matrix for a computational scratchpad
"""
mutable struct MultimembershipReMat{T, S} <: AbstractReMat{T}
    trm::Any
    levels::Any
    cnames::Vector{String}
    z::Matrix{T}
    wtz::Matrix{T}
    λ::Union{LowerTriangular{T,Matrix{T}},Diagonal{T,Vector{T}}}
    inds::Vector{Int}
    adjA::SparseMatrixCSC{T,Int32}
    scratch::Matrix{T}
end


Base.size(A::MultimembershipReMat) = reverse(size(A.adjA))

SparseArrays.sparse(A::MultimembershipReMat) = adjoint(A.adjA)

Base.getindex(A::MultimembershipReMat, i::Integer, j::Integer) = getindex(A.adjA, j, i)

nranef(A::MultimembershipReMat) = size(A.adjA, 1)

LinearAlgebra.cond(A::MultimembershipReMat) = cond(A.λ)

fname(A::MultimembershipReMat) = fname(A.trm)
getθ(A::MultimembershipReMat{T}) where {T} = getθ!(Vector{T}(undef, nθ(A)), A)

function getθ!(v::AbstractVector{T}, A::MultimembershipReMat{T}) where {T}
    length(v) == length(A.inds) || throw(DimensionMismatch("length(v) ≠ length(A.inds)"))
    m = A.λ
    @inbounds for (j, ind) in enumerate(A.inds)
        v[j] = m[ind]
    end
    return v
end

# function DataAPI.levels(A::MultimembershipReMat)
#     # These checks are for cases where unused levels are present.
#     # Such cases may never occur b/c of the way an ReMat is constructed.
#     pool = A.levels
#     present = falses(size(pool))
#     @inbounds for i in A.refs
#         present[i] = true
#         all(present) && return pool
#     end
#     return pool[present]
# end

indmat(rt::MultimembershipReMat{T,1}) where {T} = ones(Bool, 1, 1)
indmat(rt::MultimembershipReMat{T,S}) where {T,S} = reshape([i in rt.inds for i in 1:abs2(S)], S, S)

nlevs(A::MultimembershipReMat) = length(A.levels)

nθ(A::MultimembershipReMat) = length(A.inds)

function lowerbd(A::MultimembershipReMat{T}) where {T}
    return T[x ∈ diagind(A.λ) ? zero(T) : T(-Inf) for x in A.inds]
end

# function isnested(A::MultimembershipReMat, B::ReMat)
    # size(A, 1) == size(B, 1) || throw(DimensionMismatch("must have size(A,1) == size(B,1)"))
    # bins = zeros(Int32, nlevs(A))
    # @inbounds for (a, b) in zip(A.refs, B.refs)
    #     bba = bins[a]
    #     if iszero(bba)    # bins[a] not yet set?
    #         bins[a] = b   # set it
    #     elseif bba ≠ b    # set to another value?
    #         return false
    #     end
    # end
    # return true
# end

# function lmulΛ!(adjA::Adjoint{T,MultimembershipReMat{T,1}}, B::SparseMatrixCSC{T}) where {T}
#     lmul!(only(adjA.parent.λ.data), nonzeros(B))
#     return B
# end

# function lmulΛ!(adjA::Adjoint{T,MultimembershipReMat{T,1}}, B::M) where {M<:AbstractMatrix{T}} where {T}
#     return lmul!(only(adjA.parent.λ.data), B)
# end

# function lmulΛ!(adjA::Adjoint{T,MultimembershipReMat{T,S}}, B::VecOrMat{T}) where {T,S}
#     lmul!(adjoint(adjA.parent.λ), reshape(B, S, :))
#     return B
# end

# function lmulΛ!(adjA::Adjoint{T,MultimembershipReMat{T,S}}, B::BlockedSparse{T}) where {T,S}
#     lmulΛ!(adjA, nonzeros(B.cscmat))
#     return B
# end

# function lmulΛ!(adjA::Adjoint{T,MultimembershipReMat{T,1}}, B::BlockedSparse{T,1,P}) where {T,P}
#     lmul!(only(adjA.parent.λ.data), nonzeros(B.cscmat))
#     return B
# end

# function lmulΛ!(adjA::Adjoint{T,MultimembershipReMat{T,S}}, B::SparseMatrixCSC{T}) where {T,S}
#     lmulΛ!(adjA, nonzeros(B))
#     return B
# end

LinearAlgebra.Matrix(A::MultimembershipReMat) = Matrix(sparse(A))

function PCA(A::MultimembershipReMat{T,1}; corr::Bool=true) where {T}
    val = ones(T, 1, 1)
    # TODO: use DataAPI
    return PCA(corr ? val : abs(only(A.λ)) * val, A.cnames; corr=corr)
end

# TODO: use DataAPI
PCA(A::MultimembershipReMat{T,S}; corr::Bool=true) where {T,S} = PCA(A.λ, A.cnames; corr=corr)

# refarray(A::MultimembershipReMat) = A.refs

refpool(A::MultimembershipReMat) = A.levels

refvalue(A::MultimembershipReMat, i::Integer) = A.levels[i]

function reweight!(A::MultimembershipReMat, sqrtwts::Vector)
    if length(sqrtwts) > 0
        if A.z === A.wtz
            A.wtz = similar(A.z)
        end
        rmul!(copyto!(A.wtz, A.z), Diagonal(sqrtwts))
    end
    return A
end

function lmulΛ!(adjA::Adjoint{T,MultimembershipReMat{T,1}}, B::Matrix{T}) where {T}
    return lmul!(parent(adjA).λ, B)
end

function rmulΛ!(A::Matrix{T}, B::MultimembershipReMat{T,1}) where {T}
    return rmul!(A, only(B.λ.data))
end

# function rmulΛ!(A::SparseMatrixCSC{T}, B::MultimembershipReMat{T,1}) where {T}
#     rmul!(nonzeros(A), only(B.λ.data))
#     return A
# end

# function rmulΛ!(A::Matrix{T}, B::MultimembershipReMat{T,S}) where {T,S}
#     m, n = size(A)
#     q, r = divrem(n, S)
#     iszero(r) || throw(DimensionMismatch("size(A, 2) is not a multiple of block size"))
#     λ = B.λ
#     for k in 1:q
#         coloffset = (k - 1) * S
#         rmul!(view(A, :, (coloffset + 1):(coloffset + S)), λ)
#     end
#     return A
# end

# function rmulΛ!(A::BlockedSparse{T,S,P}, B::MultimembershipReMat{T,P}) where {T,S,P}
#     cbpt = A.colblkptr
#     csc = A.cscmat
#     nzv = csc.nzval
#     for j in 1:div(csc.n, P)
#         rmul!(reshape(view(nzv, cbpt[j]:(cbpt[j + 1] - 1)), :, P), B.λ)
#     end
#     return A
# end

rowlengths(A::MultimembershipReMat{T,1}) where {T} = vec(abs.(A.λ.data))

function rowlengths(A::MultimembershipReMat)
    ld = A.λ
    return if isa(ld, Diagonal)
        abs.(ld.diag)
    else
        [norm(view(ld, i, 1:i)) for i in 1:size(ld, 1)]
    end
end

# function scaleinflate!(Ljj::Diagonal{T}, Λj::MultimembershipReMat{T,1}) where {T}
#     Ljjd = Ljj.diag
#     broadcast!((x, λsqr) -> x * λsqr + 1, Ljjd, Ljjd, abs2(only(Λj.λ.data)))
#     return Ljj
# end

# XXX This isn't quite right
function scaleinflate!(Ljj::Matrix{T}, Λj::MultimembershipReMat{T,1}) where {T}
    lambsq = abs2(only(Λj.λ.data))
    @inbounds for i in axes(Ljj)
        Ljj[i] *= lambsq
    end
    @inbounds for i in diagind(Ljj)
        Ljj[i] += one(T)
    end
    return Ljj

end

# function scaleinflate!(Ljj::UniformBlockDiagonal{T}, Λj::MultimembershipReMat{T,S}) where {T,S}
#     λ = Λj.λ
#     dind = diagind(S, S)
#     Ldat = Ljj.data
#     for k in axes(Ldat, 3)
#         f = view(Ldat, :, :, k)
#         lmul!(λ', rmul!(f, λ))
#         for i in dind
#             f[i] += one(T)  # inflate diagonal
#         end
#     end
#     return Ljj
# end

# function scaleinflate!(Ljj::Matrix{T}, Λj::MultimembershipReMat{T,S}) where {T,S}
#     n = LinearAlgebra.checksquare(Ljj)
#     q, r = divrem(n, S)
#     iszero(r) || throw(DimensionMismatch("size(Ljj, 1) is not a multiple of S"))
#     λ = Λj.λ
#     offset = 0
#     @inbounds for k in 1:q
#         inds = (offset + 1):(offset + S)
#         tmp = view(Ljj, inds, inds)
#         lmul!(adjoint(λ), rmul!(tmp, λ))
#         offset += S
#     end
#     for k in diagind(Ljj)
#         Ljj[k] += 1
#     end
#     return Ljj
# end

function setθ!(A::MultimembershipReMat{T}, v::AbstractVector{T}) where {T}
    A.λ.data[A.inds] = v
    return A
end

function σs(A::MultimembershipReMat{T,1}, sc::T) where {T}
    return NamedTuple{(Symbol(only(A.cnames)),)}(sc * abs(only(A.λ.data)))
end

σs(A::MultimembershipReMat{T}, sc::T) where {T} = _σs(A.λ, sc, A.cnames)

function σρs(A::MultimembershipReMat{T,1}, sc::T) where {T}
    return NamedTuple{(:σ, :ρ)}((
        NamedTuple{(Symbol(only(A.cnames)),)}((sc * abs(only(A.λ.data)),)), ()
    ))
end

function σρs(A::MultimembershipReMat{T}, sc::T) where {T}
    return _σρs(A.λ, sc, indmat(A), Symbol.(A.cnames))
end

function corrmat(A::MultimembershipReMat{T}) where {T}
    λ = A.λ
    λnorm = rownormalize!(copy!(zeros(T, size(λ)), λ))
    return Symmetric(λnorm * λnorm', :L)
end

vsize(::DimmedReMat{T,S}) where {T,S} = S

# function zerocorr!(A::MultimembershipReMat{T}) where {T}
#     λ = A.λ = Diagonal(A.λ)
#     A.inds = intersect(A.inds, diagind(λ))
#     return A
# end
