var documenterSearchIndex = {"docs":
[{"location":"optimization/#Details-of-the-parameter-estimation","page":"Details of the parameter estimation","title":"Details of the parameter estimation","text":"","category":"section"},{"location":"optimization/#The-probability-model","page":"Details of the parameter estimation","title":"The probability model","text":"Maximum likelihood estimates are based on the probability model for the observed responses. In the probability model the distribution of the responses is expressed as a function of one or more parameters.\n\nFor a continuous distribution the probability density is a function of the responses, given the parameters. The likelihood function is the same expression as the probability density but regarding the observed values as fixed and the parameters as varying.\n\nIn general a mixed-effects model incorporates two random variables: mathcalB, the q-dimensional vector of random effects, and mathcalY, the n-dimensional response vector. The value, bf y, of mathcalY is observed; the value, bf b, of mathcalB is not.","category":"section"},{"location":"optimization/#Linear-Mixed-Effects-Models","page":"Details of the parameter estimation","title":"Linear Mixed-Effects Models","text":"In a linear mixed model the unconditional distribution of mathcalB and the conditional distribution, (mathcalY  mathcalB=bfb), are both multivariate Gaussian distributions,\n\nbeginaligned\n  (mathcalY  mathcalB=bfb) simmathcalN(bf Xbeta + Z bsigma^2bfI)\n  mathcalBsimmathcalN(bf0Sigma_theta) \nendaligned\n\nThe conditional mean of mathcal Y, given mathcal B=bf b, is the linear predictor, bf Xbfbeta+bf Zbf b, which depends on the p-dimensional fixed-effects parameter, bf beta, and on bf b. The model matrices, bf X and bf Z, of dimension ntimes p and ntimes q, respectively, are determined from the formula for the model and the values of covariates. Although the matrix bf Z can be large (i.e. both n and q can be large), it is sparse (i.e. most of the elements in the matrix are zero).\n\nThe relative covariance factor, Lambda_theta, is a qtimes q lower-triangular matrix, depending on the variance-component parameter, bftheta, and generating the symmetric qtimes q variance-covariance matrix, Sigma_theta, as\n\nSigma_theta=sigma^2Lambda_thetaLambda_theta\n\nThe spherical random effects, mathcalUsimmathcalN(bf0sigma^2bfI_q), determine mathcal B according to\n\nmathcalB=Lambda_thetamathcalU\n\nThe penalized residual sum of squares (PRSS),\n\nr^2(thetabetabfu)=bfy - bfXbeta -bfZLambda_thetabfu^2+bfu^2\n\nis the sum of the residual sum of squares, measuring fidelity of the model to the data, and a penalty on the size of bf u, measuring the complexity of the model. Minimizing r^2 with respect to bf u,\n\nr^2_betatheta =min_bfuleft(bfy -bfXbeta -bfZLambda_thetabfu^2+bfu^2right)\n\nis a direct (i.e. non-iterative) computation. The particular method used to solve this generates a blocked Choleksy factor, bfL_theta, which is an lower triangular qtimes q matrix satisfying\n\nbfL_thetabfL_theta=Lambda_thetabfZbfZLambda_theta+bfI_q \n\nwhere bf I_q is the qtimes q identity matrix.\n\nNegative twice the log-likelihood of the parameters, given the data, bf y, is\n\nd(bfthetabfbetasigmabf y)\n=nlog(2pisigma^2)+log(bf L_theta^2)+fracr^2_betathetasigma^2\n\nwhere bf L_theta denotes the determinant of bf L_theta. Because bf L_theta is triangular, its determinant is the product of its diagonal elements.\n\nBecause the conditional mean, bfmu_mathcal Ymathcal B=bf b=bf Xbfbeta+bf ZLambda_thetabf u, is a linear function of both bfbeta and bf u, minimization of the PRSS with respect to both bfbeta and bf u to produce\n\nr^2_theta =min_bfbetabf uleft(bf y -bf Xbfbeta -bf ZLambda_thetabf u^2+bf u^2right)\n\nis also a direct calculation. The values of bf u and bfbeta that provide this minimum are called, respectively, the conditional mode, tildebf u_theta, of the spherical random effects and the conditional estimate, widehatbfbeta_theta, of the fixed effects. At the conditional estimate of the fixed effects the objective is\n\nd(bfthetawidehatbeta_thetasigmabf y)\n=nlog(2pisigma^2)+log(bf L_theta^2)+fracr^2_thetasigma^2\n\nMinimizing this expression with respect to sigma^2 produces the conditional estimate\n\nwidehatsigma^2_theta=fracr^2_thetan\n\nwhich provides the profiled log-likelihood on the deviance scale as\n\ntilded(thetabf y)=d(thetawidehatbeta_thetawidehatsigma_thetabf y)\n=log(bf L_theta^2)+nleft1+logleft(frac2pi r^2_thetanright)right\n\na function of bftheta alone.\n\nThe MLE of bftheta, written widehatbftheta, is the value that minimizes this profiled objective. We determine this value by numerical optimization. In the process of evaluating tilded(widehatthetabf y) we determine widehatbeta=widehatbeta_widehattheta, tildebf u_widehattheta and r^2_widehattheta, from which we can evaluate widehatsigma=sqrtr^2_widehatthetan.\n\nThe elements of the conditional mode of mathcal B, evaluated at the parameter estimates,\n\ntildebf b_widehattheta=Lambda_widehatthetatildebf u_widehattheta\n\nare sometimes called the best linear unbiased predictors or BLUPs of the random effects. Although BLUPs an appealing acronym, I don’t find the term particularly instructive (what is a “linear unbiased predictor” and in what sense are these the “best”?) and prefer the term “conditional modes”, because these are the values of bf b that maximize the density of the conditional distribution mathcalB  mathcalY = bf y. For a linear mixed model, where all the conditional and unconditional distributions are Gaussian, these values are also the conditional means.","category":"section"},{"location":"optimization/#Internal-structure-of-\\Lambda_\\theta-and-\\bf-Z","page":"Details of the parameter estimation","title":"Internal structure of Lambda_theta and bf Z","text":"In the types of LinearMixedModel available through the MixedModels package, groups of random effects and the corresponding columns of the model matrix, bf Z, are associated with random-effects terms in the model formula.\n\nFor the simple example\n\nusing BenchmarkTools, DataFrames, MixedModels, MixedModelsDatasets\n\ndyestuff = MixedModelsDatasets.dataset(:dyestuff)\nfm1 = fit(MixedModel, @formula(yield ~ 1 + (1|batch)), dyestuff)\nDisplayAs.Text(ans) # hide\n\nthe only random effects term in the formula is (1|batch), a simple, scalar random-effects term.\n\nt1 = only(fm1.reterms);\nInt.(t1)  # convert to integers for more compact display\n\nThe matrix t1 is a sparse matrix, meaning that most of the elements are zero, and its transpose is stored in a sparse form.\n\nsparse(t1)'\n\nprovides a compact representation of the positions of the non-zeros in this matrix.\n\nThis RandomEffectsTerm contributes a block of columns to the model matrix bf Z and a diagonal block to Lambda_theta. In this case the diagonal block of Lambda_theta (which is also the only block) is a multiple of the 6times6 identity matrix where the multiple is\n\nt1.λ\n\nBecause there is only one random-effects term in the model, the matrix bf Z is the indicators matrix shown as the result of Int.(t1), but stored in a special sparse format. Furthermore, there is only one block in Lambda_theta.\n\nFor a vector-valued random-effects term, as in\n\nsleepstudy = MixedModelsDatasets.dataset(:sleepstudy)\nfm2 = fit(MixedModel, @formula(reaction ~ 1+days+(1+days|subj)), sleepstudy)\nDisplayAs.Text(ans) # hide\n\nthe model matrix bf Z is of the form\n\nt21 = only(fm2.reterms);\nsparse(t21)'\n\nand Lambda_theta is a 36times36 block diagonal matrix with 18 diagonal blocks, all of the form\n\nt21.λ\n\nThe theta vector is\n\nMixedModels.getθ(t21)\n\nRandom-effects terms in the model formula that have the same grouping factor are amalgamated into a single ReMat object.\n\nfm3 = fit(MixedModel, @formula(reaction ~ 1+days+(1|subj) + (0+days|subj)), sleepstudy)\nt31 = only(fm3.reterms);\nsparse(t31)'\n\nFor this model the matrix bf Z is the same as that of model fm2 but the diagonal blocks of Lambda_theta are themselves diagonal.\n\nt31.λ\n\nMixedModels.getθ(t31)\n\nRandom-effects terms with distinct grouping factors generate distinct elements of the reterms field of the LinearMixedModel object. Multiple ReMat objects are sorted by decreasing numbers of random effects.\n\npenicillin = MixedModelsDatasets.dataset(:penicillin)\nfm4 = fit(MixedModel,\n    @formula(diameter ~ 1 + (1|sample) + (1|plate)),\n    penicillin)\nsparse(first(fm4.reterms))'\n\nsparse(last(fm4.reterms))'\n\nNote that the first ReMat in fm4.reterms corresponds to grouping factor plate even though the term (1|plate) occurs in the formula after (1|sample).","category":"section"},{"location":"optimization/#Progress-of-the-optimization","page":"Details of the parameter estimation","title":"Progress of the optimization","text":"By default a progress display is shown when fitting a model that takes a second or more to fit. (The optional named argument, progress=false, can be used to suppress this display.) The number of iterations performed, the average time per iteration and the current value of the objective are shown in this display.\n\nAfter the model has been fit, a summary of the optimization process is available as the optsum property of the LinearMixedModel.\n\nfm2.optsum\nDisplayAs.Text(ans) # hide\n\nMore detailed information about the intermediate steps of the nonlinear optimizer can be obtained the fitlog field.\n\nfirst(fm2.optsum.fitlog, 5)\nDisplayAs.Text(ans) # hide","category":"section"},{"location":"optimization/#A-blocked-Cholesky-factor","page":"Details of the parameter estimation","title":"A blocked Cholesky factor","text":"A LinearMixedModel object contains two blocked matrices; a symmetric matrix A (only the lower triangle is stored) and a lower-triangular L which is the lower Cholesky factor of the updated and inflated A. In versions 4.0.0 and later of MixedModels only the blocks in the lower triangle are stored in A and L, as a Vector{AbstractMatrix{T}}.\n\nBlockDescription shows the structure of the blocks\n\nBlockDescription(fm2)\nDisplayAs.Text(ans) # hide\n\nAnother change in v4.0.0 and later is that the last row of blocks is constructed from m.Xymat which contains the full-rank model matrix X with the response y concatenated on the right.\n\nThe operation of installing a new value of the variance parameters, θ, and updating L\n\nis the central step in evaluating the objective (negative twice the log-likelihood).\n\nTypically, the (1,1) block is the largest block in A and L and it has a special form, either Diagonal or UniformBlockDiagonal providing a compact representation and fast matrix multiplication or solutions of linear systems of equations.","category":"section"},{"location":"optimization/#Modifying-the-optimization-process","page":"Details of the parameter estimation","title":"Modifying the optimization process","text":"The OptSummary object contains both input and output fields for the optimizer. To modify the optimization process the input fields can be changed after constructing the model but before fitting it. In addition to various tolerances, which we will not discuss further here, users can specify the choice of backend (i.e., the non-linear optimization library used) and optimizer (i.e., the implementation of an algorithm provided by the backend).\n\nThe current default backend is NLopt, which is a direct dependency of MixedModels.jl. A PRIMA backend is also provided as a package extension and thus only available when the PRIMA package is loaded. The list of currently loaded backends is available as MixedModels.OPTIMIZATION_BACKENDS. For each individual backend, the list of available optimizers can be inspected with the function MixedModels.optimizers.\n\nMixedModels.optimizers(:nlopt)\n\nSimilarly, the list of applicable optimization parameters can be inspected with the function MixedModels.opt_params.\n\nMixedModels.opt_params(:nlopt)\n\nnote: Optimizer defaults subject to change\nThe choice of default backend and optimizer is subject to change without being considered a breaking change. If you want to guarantee a particular backend and optimizer, then you should explicitly load the associated backend's package (e.g. NLopt or PRIMA) and manually set the optimizer and backend fields.\n\nSuppose, for example, that the user wishes to try a Nelder-Mead optimization method instead of the default BOBYQA (Bounded Optimization BY Quadratic Approximation) method.\n\nfm2nm = LinearMixedModel(@formula(reaction ~ 1+days+(1+days|subj)), sleepstudy);\nfm2nm.optsum.optimizer = :LN_NELDERMEAD;\nfit!(fm2nm)\nfm2nm.optsum\nDisplayAs.Text(ans) # hide\n\nThe parameter estimates are quite similar to those using :LN_BOBYQA but at the expense of 140 functions evaluations for :LN_NELDERMEAD versus 57 for :LN_BOBYQA. When plotting the progress of the individual fits, it becomes obvious that :LN_BOBYQA has fully converged by the time :LN_NELDERMEAD begins to approach the optimum.\n\nusing Gadfly\nnm = fm2nm.optsum.fitlog\nbob = fm2.optsum.fitlog\nconvdf = DataFrame(algorithm=[repeat([\"NelderMead\"], length(nm));\n                           repeat([\"BOBYQA\"], length(bob))],\n                   objective=[last.(nm); last.(bob)],\n                   step=[1:length(nm); 1:length(bob)])\nplot(convdf, x=:step, y=:objective, color=:algorithm, Geom.line)\n\nRun time can be constrained with  maxfeval and maxtime.","category":"section"},{"location":"optimization/#Convergence-to-singular-covariance-matrices","page":"Details of the parameter estimation","title":"Convergence to singular covariance matrices","text":"To ensure identifiability of Sigma_theta=sigma^2Lambda_theta Lambda_theta, the elements of theta corresponding to diagonal elements of Lambda_theta are constrained to be non-negative. For example, in a trivial case of a single, simple, scalar, random-effects term as in fm1, the one-dimensional theta vector is the ratio of the standard deviation of the random effects to the standard deviation of the response. It happens that -theta produces the same log-likelihood but, by convention, we define the standard deviation to be the positive square root of the variance. Requiring the diagonal elements of Lambda_theta to be non-negative is a generalization of using this positive square root.\n\nIf the optimization converges on the boundary of the feasible region, that is if one or more of the diagonal elements of Lambda_theta is zero at convergence, the covariance matrix Sigma_theta will be singular. This means that there will be linear combinations of random effects that are constant. Usually convergence to a singular covariance matrix is a sign of an over-specified model.\n\nSingularity can be checked with the issingular predicate function.\n\nissingular(fm2)","category":"section"},{"location":"optimization/#Generalized-Linear-Mixed-Effects-Models","page":"Details of the parameter estimation","title":"Generalized Linear Mixed-Effects Models","text":"In a generalized linear model the responses are modelled as coming from a particular distribution, such as Bernoulli for binary responses or Poisson for responses that represent counts. The scalar distributions of individual responses differ only in their means, which are determined by a linear predictor expression eta=bf Xbeta, where, as before, bf X is a model matrix derived from the values of covariates and beta is a vector of coefficients.\n\nThe unconstrained components of eta are mapped to the, possibly constrained, components of the mean response, mu, via a scalar function, g^-1, applied to each component of eta. For historical reasons, the inverse of this function, taking components of mu to the corresponding component of eta is called the link function and the more frequently used map from eta to mu is the inverse link.\n\nA generalized linear mixed-effects model (GLMM) is defined, for the purposes of this package, by\n\nbeginaligned\n  (mathcalY  mathcalB=bfb) simmathcalD(bfg^-1(Xbeta + Z b)phi)\n  mathcalBsimmathcalN(bf0Sigma_theta) \nendaligned\n\nwhere mathcalD indicates the distribution family parameterized by the mean and, when needed, a common scale parameter, phi. (There is no scale parameter for Bernoulli or for Poisson. Specifying the mean completely determines the distribution.)\n\nA GeneralizedLinearMixedModel object is generated from a formula, data frame and distribution family.\n\nverbagg = MixedModelsDatasets.dataset(:verbagg)\nconst vaform = @formula(r2 ~ 1 + anger + gender + btype + situ + (1|subj) + (1|item));\nmdl = GeneralizedLinearMixedModel(vaform, verbagg, Bernoulli());\ntypeof(mdl)\n\nA separate call to fit! can be used to fit the model. This involves optimizing an objective function, the Laplace approximation to the deviance, with respect to the parameters, which are beta, the fixed-effects coefficients, and theta, the covariance parameters. The starting estimate for beta is determined by fitting a GLM to the fixed-effects part of the formula\n\nmdl.β\n\nand the starting estimate for theta, which is a vector of the two standard deviations of the random effects, is chosen to be\n\nmdl.θ\n\nThe Laplace approximation to the deviance requires determining the conditional modes of the random effects. These are the values that maximize the conditional density of the random effects, given the model parameters and the data. This is done using Penalized Iteratively Reweighted Least Squares (PIRLS). In most cases PIRLS is fast and stable. It is simply a penalized version of the IRLS algorithm used in fitting GLMs.\n\nThe distinction between the \"fast\" and \"slow\" algorithms in the MixedModels package (nAGQ=0 or nAGQ=1 in lme4) is whether the fixed-effects parameters, beta, are optimized in PIRLS or in the nonlinear optimizer. In a call to the pirls! function the first argument is a GeneralizedLinearMixedModel, which is modified during the function call. (By convention, the names of such mutating functions end in ! as a warning to the user that they can modify an argument, usually the first argument.) The second and third arguments are optional logical values indicating if beta is to be varied and if verbose output is to be printed.\n\npirls!(mdl, true, false)\nDisplayAs.Text(ans) # hide\n\ndeviance(mdl)\n\nmdl.β\n\nmdl.θ # current values of the standard deviations of the random effects\n\nIf the optimization with respect to beta is performed within PIRLS then the nonlinear optimization of the Laplace approximation to the deviance requires optimization with respect to theta only. This is the \"fast\" algorithm. Given a value of theta, PIRLS is used to determine the conditional estimate of beta and the conditional mode of the random effects, b.\n\nmdl.b # conditional modes of b\n\nfit!(mdl, fast=true);\nDisplayAs.Text(ans) # hide\n\nThe optimization process is summarized by\n\nmdl.LMM.optsum\nDisplayAs.Text(ans) # hide\n\nAs one would hope, given the name of the option, this fit is comparatively fast.\n\n@btime fit(MixedModel, vaform, verbagg, Bernoulli(), fast=true)\nDisplayAs.Text(ans) # hide\n\nThe alternative algorithm is to use PIRLS to find the conditional mode of the random effects, given beta and theta and then use the general nonlinear optimizer to fit with respect to both beta and theta.\n\nmdl1 = @btime fit(MixedModel, vaform, verbagg, Bernoulli())\nDisplayAs.Text(ans) # hide\n\nThis fit provided slightly better results (Laplace approximation to the deviance of 8151.400 versus 8151.583) but took 6 times as long. That is not terribly important when the times involved are a few seconds but can be important when the fit requires many hours or days of computing time.","category":"section"},{"location":"optimization/#MixedModels.setθ!","page":"Details of the parameter estimation","title":"MixedModels.setθ!","text":"setθ!(m::LinearMixedModel, v)\n\nInstall v as the θ parameters in m.\n\n\n\n\n\nsetθ!(bsamp::MixedModelFitCollection, θ::AbstractVector)\nsetθ!(bsamp::MixedModelFitCollection, i::Integer)\n\nInstall the values of the i'th θ value of bsamp.fits in bsamp.λ\n\n\n\n\n\n","category":"function"},{"location":"optimization/#MixedModels.updateL!","page":"Details of the parameter estimation","title":"MixedModels.updateL!","text":"updateL!(m::LinearMixedModel)\n\nUpdate the blocked lower Cholesky factor, m.L, from m.A and m.reterms (used for λ only)\n\nThis is the crucial step in evaluating the objective, given a new parameter value.\n\n\n\n\n\n","category":"function"},{"location":"optimization/#MixedModels.issingular","page":"Details of the parameter estimation","title":"MixedModels.issingular","text":"issingular(m::MixedModel, θ=m.θ; atol::Real=0, rtol::Real=atol>0 ? 0 : √eps)\n\nTest whether the model m is singular if the parameter vector is θ.\n\nEquality comparisons are used b/c small non-negative θ values are replaced by 0 in fit!.\n\nnote: Note\nFor GeneralizedLinearMixedModel, the entire parameter vector (including β in the case fast=false) must be specified if the default is not used.\n\n\n\n\n\nissingular(bsamp::MixedModelFitCollection;\n           atol::Real=0, rtol::Real=atol>0 ? 0 : √eps))\n\nTest each bootstrap sample for singularity of the corresponding fit.\n\nEquality comparisons are used b/c small non-negative θ values are replaced by 0 in fit!.\n\nSee also issingular(::MixedModel).\n\n\n\n\n\n","category":"function"},{"location":"optimization/#Distributions.Bernoulli","page":"Details of the parameter estimation","title":"Distributions.Bernoulli","text":"Bernoulli(p)\n\nA Bernoulli distribution is parameterized by a success rate p, which takes value 1 with probability p and 0 with probability 1-p.\n\nP(X = k) = begincases\n1 - p  quad textfor  k = 0 \np  quad textfor  k = 1\nendcases\n\nBernoulli()    # Bernoulli distribution with p = 0.5\nBernoulli(p)   # Bernoulli distribution with success rate p\n\nparams(d)      # Get the parameters, i.e. (p,)\nsuccprob(d)    # Get the success rate, i.e. p\nfailprob(d)    # Get the failure rate, i.e. 1 - p\n\nExternal links:\n\nBernoulli distribution on Wikipedia\n\n\n\n\n\n","category":"type"},{"location":"optimization/#Distributions.Poisson","page":"Details of the parameter estimation","title":"Distributions.Poisson","text":"Poisson(λ)\n\nA Poisson distribution describes the number of independent events occurring within a unit time interval, given the average rate of occurrence λ.\n\nP(X = k) = fraclambda^kk e^-lambda quad text for  k = 012ldots\n\nPoisson()        # Poisson distribution with rate parameter 1\nPoisson(lambda)       # Poisson distribution with rate parameter lambda\n\nparams(d)        # Get the parameters, i.e. (λ,)\nmean(d)          # Get the mean arrival rate, i.e. λ\n\nExternal links:\n\nPoisson distribution on Wikipedia\n\n\n\n\n\n","category":"type"},{"location":"bootstrap/#Parametric-bootstrap-for-mixed-effects-models","page":"Parametric bootstrap for mixed-effects models","title":"Parametric bootstrap for mixed-effects models","text":"Julia is well-suited to implementing bootstrapping and other simulation-based methods for statistical models. The parametricbootstrap function in the MixedModels package provides an efficient parametric bootstrap for mixed-effects models.","category":"section"},{"location":"bootstrap/#The-parametric-bootstrap","page":"Parametric bootstrap for mixed-effects models","title":"The parametric bootstrap","text":"Bootstrapping is a family of procedures for generating sample values of a statistic, allowing for visualization of the distribution of the statistic or for inference from this sample of values.\n\nA parametric bootstrap is used with a parametric model, m, that has been fit to data. The procedure is to simulate n response vectors from m using the estimated parameter values and refit m to these responses in turn, accumulating the statistics of interest at each iteration.\n\nThe parameters of a LinearMixedModel object are the fixed-effects parameters, β, the standard deviation, σ, of the per-observation noise, and the covariance parameter, θ, that defines the variance-covariance matrices of the random effects.\n\nFor example, a simple linear mixed-effects model for the Dyestuff data in the lme4 package for R is fit by\n\nusing DataFrames\nusing Gadfly          # plotting package\nusing MixedModels, MixedModelsDatasets\nusing Random\n\ndyestuff = MixedModelsDatasets.dataset(:dyestuff)\nm1 = fit(MixedModel, @formula(yield ~ 1 + (1 | batch)), dyestuff)\n\nTo bootstrap the model parameters, first initialize a random number generator then create a bootstrap sample and extract the tbl property, which is a Table - a lightweight dataframe-like object.\n\nconst rng = MersenneTwister(1234321);\nsamp = parametricbootstrap(rng, 10_000, m1);\ntbl = samp.tbl\n\nA density plot of the estimates of σ, the residual standard deviation, can be created as\n\nplot(x = tbl.σ, Geom.density, Guide.xlabel(\"Parametric bootstrap estimates of σ\"))\n\nor, for the intercept parameter\n\nplot(x = tbl.β1, Geom.density, Guide.xlabel(\"Parametric bootstrap estimates of β₁\"))\n\nA density plot of the estimates of the standard deviation of the random effects is obtained as\n\nplot(x = tbl.σ1, Geom.density,\n    Guide.xlabel(\"Parametric bootstrap estimates of σ₁\"))\n\nNotice that this density plot has a spike, or mode, at zero. Although this mode appears to be diffuse, this is an artifact of the way that density plots are created. In fact, it is a pulse, as can be seen from a histogram.\n\nplot(x = tbl.σ1, Geom.histogram,\n    Guide.xlabel(\"Parametric bootstrap estimates of σ₁\"))\n\nThe bootstrap sample can be used to generate intervals that cover a certain percentage of the bootstrapped values. We refer to these as \"coverage intervals\", similar to a confidence interval. The shortest such intervals, obtained with the shortestcovint extractor, correspond to a highest posterior density interval in Bayesian inference.\n\nWe generate these directly from the original bootstrap object:\n\nTable(shortestcovint(samp))\n\nA value of zero for the standard deviation of the random effects is an example of a singular covariance. It is easy to detect the singularity in the case of a scalar random-effects term. However, it is not as straightforward to detect singularity in vector-valued random-effects terms.\n\nFor example, if we bootstrap a model fit to the sleepstudy data\n\nsleepstudy = MixedModelsDatasets.dataset(:sleepstudy)\ncontrasts = Dict(:subj => Grouping())\nm2 = let f = @formula reaction ~ 1+days+(1+days|subj)\n    fit(MixedModel, f, sleepstudy; contrasts)\nend\n\nsamp2 = parametricbootstrap(rng, 10_000, m2);\ntbl2 = samp2.tbl\n\nthe singularity can be exhibited as a standard deviation of zero or as a correlation of pm1.\n\nshortestcovint(samp2)\n\nA histogram of the estimated correlations from the bootstrap sample has a spike at +1.\n\nplot(x = tbl2.ρ1, Geom.histogram,\n    Guide.xlabel(\"Parametric bootstrap samples of correlation of random effects\"))\n\nor, as a count,\n\ncount(tbl2.ρ1 .≈ 1)\n\nClose examination of the histogram shows a few values of -1.\n\ncount(tbl2.ρ1 .≈ -1)\n\nFurthermore there are even a few cases where the estimate of the standard deviation of the random effect for the intercept is zero.\n\ncount(tbl2.σ1 .≈ 0)\n\nThere is a general condition to check for singularity of an estimated covariance matrix or matrices in a bootstrap sample. The parameter optimized in the estimation is θ, the relative covariance parameter. Some of the elements of this parameter vector must be non-negative and, when one of these components is approximately zero, one of the covariance matrices will be singular.\n\nThe issingular method for a MixedModel object that tests if a parameter vector θ corresponds to a boundary or singular fit.\n\nThis operation is encapsulated in a method for the issingular function.\n\ncount(issingular(samp2))","category":"section"},{"location":"bootstrap/#Reduced-Precision-Bootstrap","page":"Parametric bootstrap for mixed-effects models","title":"Reduced Precision Bootstrap","text":"parametricbootstrap accepts an optional keyword argument optsum_overrides, which can be used to override the convergence criteria for bootstrap replicates. One possibility is setting ftol_rel=1e-8, i.e., considering the model converged when the relative change in the objective between optimizer iterations is smaller than 0.00000001. This threshold corresponds approximately to the precision from treating the value of the objective as a single precision (Float32) number, while not changing the precision of the intermediate computations. The resultant loss in precision will generally be smaller than the variation that the bootstrap captures, but can greatly speed up the fitting process for each replicates, especially for large models. More directly, lowering the fit quality for each replicate will reduce the quality of each replicate, but this may be more than compensated for by the ability to fit a much larger number of replicates in the same time.\n\nt = @timed parametricbootstrap(MersenneTwister(42), 1000, m2; progress=false)\nt.time\n\noptsum_overrides = (; ftol_rel=1e-8)\nt = @timed parametricbootstrap(MersenneTwister(42), 1000, m2; optsum_overrides, progress=false)\nt.time","category":"section"},{"location":"bootstrap/#Distributed-Computing-and-the-Bootstrap","page":"Parametric bootstrap for mixed-effects models","title":"Distributed Computing and the Bootstrap","text":"Earlier versions of MixedModels.jl supported a multi-threaded bootstrap via the use_threads keyword argument. However, with improved BLAS multithreading, the Julia-level threads often wound up competing with the BLAS threads, leading to no improvement or even a worsening of performance when use_threads=true. Nonetheless, the bootstrap is a classic example of an embarrassingly parallel problem and so we provide a few convenience methods for combining results computed separately. In particular, there are vcat and an optimized reduce(::typeof(vcat)) methods for MixedModelBootstrap objects. For computers with many processors (as opposed to a single processor with several cores) or for computing clusters, these provide a convenient way to split the computation across nodes.\n\nusing Distributed\n# you already have 1 proc by default, so add the number of additional cores with `addprocs`\n# you need at least as many RNGs as cores you want to use in parallel\n# but you shouldn't use all of your cores because nested within this\n# is the multithreading of the linear algebra\n# addprocs(1)\n@info \"Currently using $(nprocs()) processors total and $(nworkers()) for work\"\n\n# Load the necessary packages on all workers\n# For clusters, you will also need to make sure that the Julia\n# environment (Project.toml) is set up and activated on each worker.\n@everywhere begin\n    using ProgressMeter\n    using MixedModels\nend\n# copy everything to workers\n@showprogress for w in workers()\n    remotecall_fetch(() -> coefnames(m2), w)\nend\n\n# split the replicates across the workers\n# this rounds down, so if the number of workers doesn't divide the\n# number of replicates, you'll be a few replicates short!\nn_replicates = 1000\nn_rep_per_worker = n_replicates ÷ nworkers()\n# NB: You need a different seed/RNG for each worker otherwise you will\n# have copies of the same replicates and not independent replicates!\npb_map = @showprogress pmap(MersenneTwister.(1:nworkers())) do rng\n    parametricbootstrap(rng, n_rep_per_worker, m2; optsum_overrides)\nend;\n\n# get rid of all the workers\n# rmprocs(workers())\n\nconfint(reduce(vcat, pb_map))","category":"section"},{"location":"bootstrap/#MixedModels.parametricbootstrap","page":"Parametric bootstrap for mixed-effects models","title":"MixedModels.parametricbootstrap","text":"parametricbootstrap([rng::AbstractRNG], nsamp::Integer, m::MixedModel{T}, ftype=T;\n    β = fixef(m), σ = m.σ, θ = m.θ, progress=true, optsum_overrides=(;))\n\nPerform nsamp parametric bootstrap replication fits of m, returning a MixedModelBootstrap.\n\nThe default random number generator is Random.GLOBAL_RNG.\n\nftype can be used to store the computed bootstrap values in a lower precision. ftype is not a named argument because named arguments are not used in method dispatch and thus specialization. In other words, having ftype as a positional argument has some potential performance benefits.\n\nKeyword Arguments\n\nβ, σ, and θ are the values of m's parameters for simulating the responses.\nσ is only valid for LinearMixedModel and GeneralizedLinearMixedModel for\n\nfamilies with a dispersion parameter.\n\nprogress controls whether the progress bar is shown. Note that the progress\n\nbar is automatically disabled for non-interactive (i.e. logging) contexts.\n\noptsum_overrides is used to override values of OptSummary in the models\n\nfit during the bootstrapping process. For example, optsum_overrides=(;ftol_rel=1e-08) reduces the convergence criterion, which can greatly speed up the bootstrap fits. Taking advantage of this speed up to increase n can often lead to better estimates of coverage intervals.\n\nnote: Note\nAll coefficients are bootstrapped. In the rank deficient case, the inestimatable coefficients are treated as -0.0 in the simulations underlying the bootstrap, which will generally result in their estimate from the simulated data also being being inestimable and thus set to -0.0. However this behavior may change in future releases to explicitly drop the extraneous columns before simulation and thus not include their estimates in the bootstrap result.\n\n\n\n\n\n","category":"function"},{"location":"bootstrap/#MixedModels.shortestcovint","page":"Parametric bootstrap for mixed-effects models","title":"MixedModels.shortestcovint","text":"shortestcovint(v, level = 0.95)\n\nReturn the shortest interval containing level proportion of the values of v\n\n\n\n\n\nshortestcovint(bsamp::MixedModelFitCollection, level = 0.95)\n\nReturn the shortest interval containing level proportion for each parameter from bsamp.allpars.\n\nwarning: Warning\nCurrently, correlations that are systematically zero are included in the the result. This may change in a future release without being considered a breaking change.\n\n\n\n\n\n","category":"function"},{"location":"limitations/#Limitations-of-MixedModels.jl","page":"Limitations of MixedModels.jl","title":"Limitations of MixedModels.jl","text":"We expect that MixedModels.jl will generally be best in class for the types of models that it can fit. We use cutting edge algorithms based on penalized least squares and sparse matrix methods that take advantage of the particular sparsity and structure that arises in the case of the linear mixed effects model with an unconstrained covariance structure. Glossing over a fair number of technical details, MixedModels.jl uses a different, novel formulation of the underlying numerical problem which tends to be much more efficient computationally and allows us to fit models with multiple crossed, partially crossed or nested grouping variables without any special treatment.","category":"section"},{"location":"limitations/#Very-few-options-for-covariance-structure","page":"Limitations of MixedModels.jl","title":"Very few options for covariance structure","text":"Nonetheless, there is no free lunch and the tradeoff that we make is that it is much more difficult to formulate constraints on the covariance structure (whether on the random effects or on the response/residuals) in our formulation. MixedModels.jl currently supports precisely two covariance structures explicitly:\n\nunconstrained\nzero correlation (diagonal covariance structure)\n\nIt is also possible to express some models with compound symmetry by clever manipulation of the formula syntax (i.e. (1+c|g) for categorical c with compound symmetry is the same as (1|g) + (1|g&c)).\n\nMixedModels.jl does support constraining the residual variance to known scalar value, which is useful in meta-analysis.\n\nMetida.jl may provide an alternative if this functionality is required (not an endorsement).","category":"section"},{"location":"limitations/#No-support-for-sandwich/robust-variance-covariance-estimators","page":"Limitations of MixedModels.jl","title":"No support for sandwich/robust variance-covariance estimators","text":"This may change in the foreseeable future!\n\nIf this would be a valuable feature, then please file an issue. Issues are prioritized by the developers' own needs and potential impact for users, so showing a large need for a feature will tend to increase its priority.\n\nFixedEffectsModels.jl may be a viable alternative (not an endorsement). It provides \"fast estimation of linear models with IV and high dimensional categorical variables\" and provides similar functionality to Stata's reghdfe and R's lfe and fixest.","category":"section"},{"location":"limitations/#No-support-for-generalized-linear-mixed-models-with-a-dispersion-parameter","page":"Limitations of MixedModels.jl","title":"No support for generalized linear mixed models with a dispersion parameter","text":"While MixedModels.jl does nominally support any GLM family and link function support by GLM.jl, the results for model families with a dispersion parameter (normal with non-identity link, gamma, inverse Gaussian) are known to be incorrect. The package issues a warning if you attempt to fit such models.","category":"section"},{"location":"limitations/#No-support-for-polytomous-responses","page":"Limitations of MixedModels.jl","title":"No support for polytomous responses","text":"Multinomial and ordered responses are not supported. We are unaware of a Julia package offering support for this.","category":"section"},{"location":"limitations/#No-support-for-regularization-of-the-fixed-effects","page":"Limitations of MixedModels.jl","title":"No support for regularization of the fixed effects","text":"HighDimMixedModels.jl may provide an alternative if this functionality is required (not an endorsement).","category":"section"},{"location":"limitations/#No-support-for-generalized-additive-mixed-models","page":"Limitations of MixedModels.jl","title":"No support for generalized additive mixed models","text":"Generalized additive models can be expressed a mixed model, so supporting this would require \"only\" adding a translation layer.","category":"section"},{"location":"limitations/#No-support-for-nonlinear-mixed-effects-models","page":"Limitations of MixedModels.jl","title":"No support for nonlinear mixed effects models","text":"Pumas.jl (commercial) provides this (not an endorsement).","category":"section"},{"location":"limitations/#No-support-for-Satterthwaite-nor-Kenward-Roger-degree-of-freedom-approximations.","page":"Limitations of MixedModels.jl","title":"No support for Satterthwaite nor Kenward-Roger degree of freedom approximations.","text":"There are some philosophical and practical issues with these approaches, but an implementation can be found in MixedModelsSmallSample.jl (not an endorsement).","category":"section"},{"location":"GaussHermite/#Normalized-Gauss-Hermite-Quadrature","page":"Normalized Gauss-Hermite Quadrature","title":"Normalized Gauss-Hermite Quadrature","text":"Gaussian Quadrature rules provide sets of x values, called abscissae, and corresponding weights, w, to approximate an integral with respect to a weight function, g(x). For a kth order rule the approximation is\n\nint f(x)g(x)dx approx sum_i=1^k w_i f(x_i)\n\nFor the Gauss-Hermite rule the weight function is\n\ng(x) = e^-x^2\n\nand the domain of integration is (-infty infty). A slight variation of this is the normalized Gauss-Hermite rule for which the weight function is the standard normal density\n\ng(z) = phi(z) = frace^-z^22sqrt2pi\n\nThus, the expected value of f(z), where mathcalZsimmathscrN(01), is approximated as\n\nmathbbEf=int_-infty^infty f(z) phi(z)dzapproxsum_i=1^k w_if(z_i) \n\nNaturally, there is a caveat. For the approximation to be accurate the function f(z) must behave like a low-order polynomial over the range of interest. More formally, a kth order rule is exact when f is a polynomial of order 2k-1 or less. [1]","category":"section"},{"location":"GaussHermite/#Evaluating-the-weights-and-abscissae","page":"Normalized Gauss-Hermite Quadrature","title":"Evaluating the weights and abscissae","text":"In the Golub-Welsch algorithm the abscissae for a particular Gaussian quadrature rule are determined as the eigenvalues of a symmetric tri-diagonal matrix and the weights are derived from the squares of the first row of the matrix of eigenvectors. For a kth order normalized Gauss-Hermite rule the tridiagonal matrix has zeros on the diagonal and the square roots of 1:k-1 on the super- and sub-diagonal, e.g.\n\nusing DataFrames, LinearAlgebra, Gadfly\nsym3 = SymTridiagonal(zeros(3), sqrt.(1:2))\nev = eigen(sym3);\nev.values\n\nabs2.(ev.vectors[1,:])\n\nAs a function of k this can be written as\n\nfunction gausshermitenorm(k)\n    ev = eigen(SymTridiagonal(zeros(k), sqrt.(1:k-1)))\n    ev.values, abs2.(ev.vectors[1,:])\nend;\n\nproviding\n\ngausshermitenorm(3)\n\nThe weights and positions are often shown as a lollipop plot. For the 9th order rule these are\n\ngh9=gausshermitenorm(9)\nplot(x=gh9[1], y=gh9[2], Geom.hair, Geom.point, Guide.ylabel(\"Weight\"), Guide.xlabel(\"\"))\n\nNotice that the magnitudes of the weights drop quite dramatically away from zero, even on a logarithmic scale\n\nplot(\n    x=gh9[1], y=gh9[2], Geom.hair, Geom.point,\n    Scale.y_log2, Guide.ylabel(\"Weight (log scale)\"),\n    Guide.xlabel(\"\"),\n)\n\nThe definition of MixedModels.GHnorm is similar to the gausshermitenorm function with some extra provisions for ensuring symmetry of the abscissae and the weights and for caching values once they have been calculated.\n\nusing MixedModels, MixedModelsDatasets\nGHnorm(3)\n\nBy the properties of the normal distribution, when mathcalXsimmathscrN(mu sigma^2)\n\nmathbbEg(x) approx sum_i=1^k g(mu + sigma z_i)w_i\n\nFor example, mathbbEmathcalX^2 where mathcalXsimmathcalN(2 3^2) is\n\nμ = 2; σ = 3; ghn3 = GHnorm(3);\nsum(@. ghn3.w * abs2(μ + σ * ghn3.z))  # should be μ² + σ² = 13\n\n(In general a dot, '.', after the function name in a function call, as in abs2.(...), or before an operator creates a fused vectorized evaluation in Julia. The macro @. has the effect of vectorizing all operations in the subsequent expression.)","category":"section"},{"location":"GaussHermite/#Application-to-a-model-for-contraception-use","page":"Normalized Gauss-Hermite Quadrature","title":"Application to a model for contraception use","text":"A binary response is a \"Yes\"/\"No\" type of answer. For example, in a 1989 fertility survey of women in Bangladesh (reported in Huq, N. M. and Cleland, J., 1990) one response of interest was whether the woman used artificial contraception. Several covariates were recorded including the woman's age (centered at the mean), the number of live children the woman has had (in 4 categories: 0, 1, 2, and 3 or more), whether she lived in an urban setting, and the district in which she lived. The version of the data used here is that used in review of multilevel modeling software conducted by the Center for Multilevel Modelling, currently at University of Bristol (http://www.bristol.ac.uk/cmm/learning/mmsoftware/data-rev.html). These data are available as the :contra dataset.\n\ncontra = DataFrame(MixedModelsDatasets.dataset(:contra))\ndescribe(contra)\n\nA smoothed scatterplot of contraception use versus age\n\nplot(contra, x=:age, y=:use, Geom.smooth, Guide.xlabel(\"Centered age (yr)\"),\n    Guide.ylabel(\"Contraception use\"))\n\nshows that the proportion of women using artificial contraception is approximately quadratic in age.\n\nA model with fixed-effects for age, age squared, number of live children and urban location and with random effects for district, is fit as\n\nconst form1 = @formula use ~ 1 + age + abs2(age) + livch + urban + (1|dist);\nm1 = fit(MixedModel, form1, contra, Bernoulli(), fast=true)\nDisplayAs.Text(ans) # hide\n\nFor a model such as m1, which has a single, scalar random-effects term, the unscaled conditional density of the spherical random effects variable, mathcalU, given the observed data, mathcalY=mathbfy_0, can be expressed as a product of scalar density functions, f_i(u_i) i=1dotsq. In the PIRLS algorithm, which determines the conditional mode vector, tildemathbfu, the optimization is performed on the deviance scale,\n\nD(mathbfu)=-2sum_i=1^q log(f_i(u_i))\n\nThe objective, D, consists of two parts: the sum of the (squared) deviance residuals, measuring fidelity to the data, and the squared length of mathbfu, which is the penalty. In the PIRLS algorithm, only the sum of these components is needed. To use Gauss-Hermite quadrature the contributions of each of the u_ii=1dotsq should be separately evaluated.\n\nconst devc0 = map!(abs2, m1.devc0, m1.u[1]);  # start with uᵢ²\nconst devresid = m1.resp.devresid;   # n-dimensional vector of deviance residuals\nconst refs = only(m1.LMM.reterms).refs;  # n-dimensional vector of indices in 1:q\nfor (dr, i) in zip(devresid, refs)\n    devc0[i] += dr\nend\nshow(devc0)\n\nOne thing to notice is that, even on the deviance scale, the contributions of different districts can be of different magnitudes. This is primarily due to different sample sizes in the different districts.\n\nusing FreqTables\nfreqtable(contra, :dist)'\n\nBecause the first district has one of the largest sample sizes and the third district has the smallest sample size, these two will be used for illustration. For a range of u values, evaluate the individual components of the deviance and store them in a matrix.\n\nconst devc = m1.devc;\nconst xvals = -5.0:2.0^(-4):5.0;\nconst uv = vec(m1.u[1]);\nconst u₀ = vec(m1.u₀[1]);\nresults = zeros(length(devc0), length(xvals))\nfor (j, u) in enumerate(xvals)\n    fill!(devc, abs2(u))\n    fill!(uv, u)\n    MixedModels.updateη!(m1)\n    for (dr, i) in zip(devresid, refs)\n        devc[i] += dr\n    end\n    copyto!(view(results, :, j), devc)\nend\n\nA plot of the deviance contribution versus u_1\n\nplot(x=xvals, y=view(results, 1, :), Geom.line, Guide.xlabel(\"u₁\"),\n    Guide.ylabel(\"Deviance contribution\"))\n\nshows that the deviance contribution is very close to a quadratic. This is also true for u_3\n\nplot(x=xvals, y=view(results, 3, :), Geom.line, Guide.xlabel(\"u₃\"),\n    Guide.ylabel(\"Deviance contribution\"))\n\nThe PIRLS algorithm provides the locations of the minima of these scalar functions, stored as\n\nm1.u₀[1]\n\nthe minima themselves, evaluated as devc0 above, and a horizontal scale, which is the inverse of diagonal of the Cholesky factor. As shown below, this is an estimate of the conditional standard deviations of the components of mathcalU.\n\nusing MixedModels: block\nconst s = inv.(m1.LMM.L[block(1,1)].diag);\ns'\n\nThe curves can be put on a common scale, corresponding to the standard normal, as\n\nfor (j, z) in enumerate(xvals)\n    @. uv = u₀ + z * s\n    MixedModels.updateη!(m1)\n    @. devc = abs2(uv) - devc0\n    for (dr, i) in zip(devresid, refs)\n        devc[i] += dr\n    end\n    copyto!(view(results, :, j), devc)\nend\n\nplot(x=xvals, y=view(results, 1, :), Geom.line,\n    Guide.xlabel(\"Scaled and shifted u₁\"),\n    Guide.ylabel(\"Shifted deviance contribution\"))\n\nplot(x=xvals, y=view(results, 3, :), Geom.line,\n    Guide.xlabel(\"Scaled and shifted u₃\"),\n    Guide.ylabel(\"Shifted deviance contribution\"))\n\nOn the original density scale these become\n\nfor (j, z) in enumerate(xvals)\n    @. uv = u₀ + z * s\n    MixedModels.updateη!(m1)\n    @. devc = abs2(uv) - devc0\n    for (dr, i) in zip(devresid, refs)\n        devc[i] += dr\n    end\n    copyto!(view(results, :, j), @. exp(-devc/2))\nend\n\nplot(x=xvals, y=view(results, 1, :), Geom.line,\n    Guide.xlabel(\"Scaled and shifted u₁\"),\n    Guide.ylabel(\"Conditional density\"))\n\nplot(x=xvals, y=view(results, 3, :), Geom.line,\n    Guide.xlabel(\"Scaled and shifted u₃\"),\n    Guide.ylabel(\"Conditional density\"))\n\nand the function to be integrated with the normalized Gauss-Hermite rule is\n\nfor (j, z) in enumerate(xvals)\n    @. uv = u₀ + z * s\n    MixedModels.updateη!(m1)\n    @. devc = abs2(uv) - devc0\n    for (dr, i) in zip(devresid, refs)\n        devc[i] += dr\n    end\n    copyto!(view(results, :, j), @. exp((abs2(z) - devc)/2))\nend\n\nplot(x=xvals, y=view(results, 1, :), Geom.line,\n    Guide.xlabel(\"Scaled and shifted u₁\"), Guide.ylabel(\"Kernel ratio\"))\n\nplot(x=xvals, y=view(results, 3, :), Geom.line,\n    Guide.xlabel(\"Scaled and shifted u₃\"), Guide.ylabel(\"Kernel ratio\"))\n\n[1]: https://en.wikipedia.org/wiki/Gaussian_quadrature","category":"section"},{"location":"GaussHermite/#MixedModels.GHnorm","page":"Normalized Gauss-Hermite Quadrature","title":"MixedModels.GHnorm","text":"GHnorm(k::Int)\n\nReturn the (unique) GaussHermiteNormalized{k} object.\n\nThe function values are stored (memoized) when first evaluated.  Subsequent evaluations for the same k have very low overhead.\n\n\n\n\n\n","category":"function"},{"location":"constructors/#Model-constructors","page":"Model constructors","title":"Model constructors","text":"The LinearMixedModel type represents a linear mixed-effects model. Typically, it is constructed from a Formula and an appropriate Table type, usually a DataFrame.","category":"section"},{"location":"constructors/#Examples-of-linear-mixed-effects-model-fits","page":"Model constructors","title":"Examples of linear mixed-effects model fits","text":"For illustration, several data sets from the lme4 package for R are made available in .arrow format in this package. Often, for convenience, we will convert these to DataFrames. These data sets include the dyestuff and dyestuff2 data sets.\n\nusing DataFrames, MixedModels, MixedModelsDatasets, StatsModels\ndyestuff = MixedModelsDatasets.dataset(:dyestuff)\n\ndescribe(DataFrame(dyestuff))","category":"section"},{"location":"constructors/#The-@formula-language-in-Julia","page":"Model constructors","title":"The @formula language in Julia","text":"MixedModels.jl builds on the Julia formula language provided by StatsModels.jl, which is similar to the formula language in R and is also based on the notation from Wilkinson and Rogers (1973). There are two ways to construct a formula in Julia.  The first way is to enclose the formula expression in the @formula macro:\n\nThe second way is to combine Terms with operators like +, &, ~, and others at \"run time\".  This is especially useful if you wish to create a formula from a list a variable names.  For instance, the following are equivalent:\n\n@formula(y ~ 1 + a + b + a & b) == (term(:y) ~ term(1) + term(:a) + term(:b) + term(:a) & term(:b))\n\nMixedModels.jl provides additional formula syntax for representing random-effects terms.  Most importantly, | separates random effects and their grouping factors (as in the formula extension used by the R package lme4).  Much like with the base formula language, | can be used within the @formula macro and to construct a formula programmatically:\n\n@formula(y ~ 1 + a + b + (1 + a + b | g))\n\nterms = sum(term(t) for t in [1, :a, :b])\ngroup = term(:g)\nresponse = term(:y)\nresponse ~ terms + (terms | group)","category":"section"},{"location":"constructors/#Models-with-simple,-scalar-random-effects","page":"Model constructors","title":"Models with simple, scalar random effects","text":"A basic model with simple, scalar random effects for the levels of batch (the batch of an intermediate product, in this case) is declared and fit as\n\nfm = @formula(yield ~ 1 + (1|batch))\nfm1 = fit(MixedModel, fm, dyestuff)\nDisplayAs.Text(ans) # hide\n\nYou can also use the convenience function lmm to fit the model as follows:\n\nfm = @formula(yield ~ 1 + (1|batch))\nfm2 = lmm(fm, dyestuff)\nDisplayAs.Text(ans) # hide\n\nNotice that both are equivalent.\n\n(If you are new to Julia you may find that this first fit takes an unexpectedly long time, due to Just-In-Time (JIT) compilation of the code. The subsequent calls to such functions are much faster.)\n\nusing BenchmarkTools\ndyestuff2 = MixedModelsDatasets.dataset(:dyestuff2)\n@benchmark fit(MixedModel, $fm, $dyestuff2)\n\nBy default, the model is fit by maximum likelihood. To use the REML criterion instead, add the optional named argument REML=true to the call to fit\n\nfm1reml = fit(MixedModel, fm, dyestuff, REML=true)\nDisplayAs.Text(ans) # hide","category":"section"},{"location":"constructors/#Floating-point-type-in-the-model","page":"Model constructors","title":"Floating-point type in the model","text":"The type of fm1\n\ntypeof(fm1)\n\nincludes the floating point type used internally for the various matrices, vectors, and scalars that represent the model. At present, this will always be Float64 because the parameter estimates are optimized using the NLopt package which calls compiled C code that only allows for optimization with respect to a Float64 parameter vector.\n\nSo in theory other floating point types, such as BigFloat or Float32, can be used to define a model but in practice only Float64 works at present.\n\nIn theory, theory and practice are the same.  In practice, they aren't.  – Anon","category":"section"},{"location":"constructors/#Simple,-scalar-random-effects","page":"Model constructors","title":"Simple, scalar random effects","text":"A simple, scalar random effects term in a mixed-effects model formula is of the form (1|G). All random effects terms end with |G where G is the grouping factor for the random effect. The name or, more generally the expression, G, should evaluate to a categorical array that has a distinct set of levels. The random effects are associated with the levels of the grouping factor.\n\nA scalar random effect is, as the name implies, one scalar value for each level of the grouping factor. A simple, scalar random effects term is of the form, (1|G). It corresponds to a shift in the intercept for each level of the grouping factor.","category":"section"},{"location":"constructors/#Models-with-vector-valued-random-effects","page":"Model constructors","title":"Models with vector-valued random effects","text":"The sleepstudy data are observations of reaction time, reaction, on several subjects, subj, after 0 to 9 days of sleep deprivation, days. A model with random intercepts and random slopes for each subject, allowing for within-subject correlation of the slope and intercept, is fit as\n\nsleepstudy = MixedModelsDatasets.dataset(:sleepstudy)\nfm2 = fit(MixedModel, @formula(reaction ~ 1 + days + (1 + days|subj)), sleepstudy)\nDisplayAs.Text(ans) # hide","category":"section"},{"location":"constructors/#Models-with-multiple,-scalar-random-effects-terms","page":"Model constructors","title":"Models with multiple, scalar random-effects terms","text":"A model for the Penicillin data incorporates random effects for the plate, and for the sample. As every sample is used on every plate these two factors are crossed.\n\npenicillin = MixedModelsDatasets.dataset(:penicillin)\nfm3 = fit(MixedModel, @formula(diameter ~ 1 + (1|plate) + (1|sample)), penicillin)\nDisplayAs.Text(ans) # hide\n\nIn contrast, the cask grouping factor is nested within the batch grouping factor in the Pastes data.\n\npastes = DataFrame(MixedModelsDatasets.dataset(:pastes))\ndescribe(pastes)\n\nThis can be expressed using the solidus (the \"/\" character) to separate grouping factors, read \"cask nested within batch\":\n\nfm4a = fit(MixedModel, @formula(strength ~ 1 + (1|batch/cask)), pastes)\nDisplayAs.Text(ans) # hide\n\nIf the levels of the inner grouping factor are unique across the levels of the outer grouping factor, then this nesting does not need to expressed explicitly in the model syntax. For example, defining sample to be the combination of batch and cask, yields a naming scheme where the nesting is apparent from the data even if not expressed in the formula. (That is, each level of sample occurs in conjunction with only one level of batch.) As such, this model is equivalent to the previous one.\n\npastes.sample = (string.(pastes.cask, \"&\",  pastes.batch))\nfm4b = fit(MixedModel, @formula(strength ~ 1 + (1|sample) + (1|batch)), pastes)\nDisplayAs.Text(ans) # hide\n\nIn observational studies it is common to encounter partially crossed grouping factors. For example, the InstEval data are course evaluations by students, s, of instructors, d. Additional covariates include the academic department, dept, in which the course was given and service, whether or not it was a service course.\n\ninsteval = MixedModelsDatasets.dataset(:insteval)\nfm5 = fit(MixedModel, @formula(y ~ 1 + service * dept + (1|s) + (1|d)), insteval)\nDisplayAs.Text(ans) # hide","category":"section"},{"location":"constructors/#Simplifying-the-random-effect-correlation-structure","page":"Model constructors","title":"Simplifying the random effect correlation structure","text":"MixedModels.jl estimates not only the variance of the effects for each random effect level, but also the correlation between the random effects for different predictors. So, for the model of the sleepstudy data above, one of the parameters that is estimated is the correlation between each subject's random intercept (i.e., their baseline reaction time) and slope (i.e., their particular change in reaction time per day of sleep deprivation). In some cases, you may wish to simplify the random effects structure by removing these correlation parameters. This often arises when there are many random effects you want to estimate (as is common in psychological experiments with many conditions and covariates), since the number of random effects parameters increases as the square of the number of predictors, making these models difficult to estimate from limited data.\n\nThe special syntax zerocorr can be applied to individual random effects terms inside the @formula:\n\nfm2zerocorr_fm = fit(MixedModel, @formula(reaction ~ 1 + days + zerocorr(1 + days|subj)), sleepstudy)\nDisplayAs.Text(ans) # hide\n\nAlternatively, correlations between parameters can be removed by including them as separate random effects terms:\n\nfit(MixedModel, @formula(reaction ~ 1 + days + (1|subj) + (days|subj)), sleepstudy)\nDisplayAs.Text(ans) # hide\n\nFinally, for predictors that are categorical, MixedModels.jl will estimate correlations between each level. Notice the large number of correlation parameters if we treat days as a categorical variable by giving it contrasts:\n\nfit(MixedModel, @formula(reaction ~ 1 + days + (1 + days|subj)), sleepstudy,\n    contrasts = Dict(:days => DummyCoding()))\nDisplayAs.Text(ans) # hide\n\nSeparating the 1 and days random effects into separate terms removes the correlations between the intercept and the levels of days, but not between the levels themselves:\n\nfit(MixedModel, @formula(reaction ~ 1 + days + (1|subj) + (days|subj)), sleepstudy,\n    contrasts = Dict(:days => DummyCoding()))\nDisplayAs.Text(ans) # hide\n\n(Notice that the variance component for days: 1 is estimated as zero, so the correlations for this component are undefined and expressed as NaN, not a number.)\n\nAn alternative is to force all the levels of days as indicators using fulldummy encoding.\n\nfit(MixedModel, @formula(reaction ~ 1 + days + (1 + fulldummy(days)|subj)), sleepstudy,\n    contrasts = Dict(:days => DummyCoding()))\nDisplayAs.Text(ans) # hide\n\nThis fit produces a better fit as measured by the objective (negative twice the log-likelihood is 1610.8) but at the expense of adding many more parameters to the model. As a result, model comparison criteria such, as AIC and BIC, are inflated.\n\nBut using zerocorr on the individual terms does remove the correlations between the levels:\n\nfit(MixedModel, @formula(reaction ~ 1 + days + zerocorr(1 + days|subj)), sleepstudy,\n    contrasts = Dict(:days => DummyCoding()))\nDisplayAs.Text(ans) # hide\n\nfit(MixedModel, @formula(reaction ~ 1 + days + (1|subj) + zerocorr(days|subj)), sleepstudy,\n    contrasts = Dict(:days => DummyCoding()))\nDisplayAs.Text(ans) # hide\n\nfit(MixedModel, @formula(reaction ~ 1 + days + zerocorr(1 + fulldummy(days)|subj)), sleepstudy,\n    contrasts = Dict(:days => DummyCoding()))\nDisplayAs.Text(ans) # hide","category":"section"},{"location":"constructors/#Fitting-generalized-linear-mixed-models","page":"Model constructors","title":"Fitting generalized linear mixed models","text":"To create a GLMM representation, the distribution family for the response, and possibly the link function, must be specified. You can either use fit(MixedModel, ...) or glmm(...) to fit the model. For instance:\n\nverbagg = MixedModelsDatasets.dataset(:verbagg)\nverbaggform = @formula(r2 ~ 1 + anger + gender + btype + situ + mode + (1|subj) + (1|item));\ngm1 = fit(MixedModel, verbaggform, verbagg, Bernoulli())\nDisplayAs.Text(ans) # hide\n\nThe model can also be fit as\n\ngm1 = glmm(verbaggform, verbagg, Bernoulli())\n\nThe canonical link, which is LogitLink for the Bernoulli distribution, is used if no explicit link is specified.\n\nNote that, in keeping with convention in the GLM package, the distribution family for a binary (i.e. 0/1) response is the Bernoulli distribution. The Binomial distribution is only used when the response is the fraction of trials returning a positive, in which case the number of trials must be specified as the case weights.","category":"section"},{"location":"constructors/#Optional-arguments-to-fit","page":"Model constructors","title":"Optional arguments to fit","text":"An alternative approach is to create the GeneralizedLinearMixedModel object then call fit! on it. The optional arguments fast and/or nAGQ can be passed to the optimization process via both fit and fit! (i.e these optimization settings are not used nor recognized when constructing the model).\n\nAs the name implies, fast=true, provides a faster but somewhat less accurate fit. These fits may suffice for model comparisons.\n\ngm1a = fit(MixedModel, verbaggform, verbagg, Bernoulli(), fast = true)\ndeviance(gm1a) - deviance(gm1)\n\n@benchmark fit(MixedModel, $verbaggform, $verbagg, Bernoulli())\n\n@benchmark fit(MixedModel, $verbaggform, $verbagg, Bernoulli(), fast = true)\n\nThe optional argument nAGQ=k causes evaluation of the deviance function to use a k point adaptive Gauss-Hermite quadrature rule. This method only applies to models with a single, simple, scalar random-effects term, such as\n\ncontraception = MixedModelsDatasets.dataset(:contra)\ncontraform = @formula(use ~ 1 + age + abs2(age) + livch + urban + (1|dist));\nbernoulli = Bernoulli()\ndeviances = Dict{Symbol,Float64}()\nb = @benchmarkable deviances[:default] = deviance(fit(MixedModel, $contraform, $contraception, $bernoulli));\nrun(b)\nb = @benchmarkable deviances[:fast] = deviance(fit(MixedModel, $contraform, $contraception, $bernoulli, fast = true));\nrun(b)\nb = @benchmarkable deviances[:nAGQ] = deviance(fit(MixedModel, $contraform, $contraception, $bernoulli, nAGQ=9));\nrun(b)\nb = @benchmarkable deviances[:nAGQ_fast] = deviance(fit(MixedModel, $contraform, $contraception, $bernoulli, nAGQ=9, fast=true));\nrun(b)\nsort(deviances)","category":"section"},{"location":"constructors/#Extractor-functions","page":"Model constructors","title":"Extractor functions","text":"LinearMixedModel and GeneralizedLinearMixedModel are subtypes of StatsAPI.RegressionModel which, in turn, is a subtype of StatsBase.StatisticalModel. Many of the generic extractors defined in the StatsBase package have methods for these models.","category":"section"},{"location":"constructors/#Model-fit-statistics","page":"Model constructors","title":"Model-fit statistics","text":"The statistics describing the quality of the model fit include\n\nloglikelihood(fm1)\n\naic(fm1)\n\nbic(fm1)\n\ndof(fm1)   # 1 fixed effect, 2 variances\n\nnobs(fm1)  # 30 observations\n\nloglikelihood(gm1)\n\nIn general the deviance of a statistical model fit is negative twice the log-likelihood adjusting for the saturated model.\n\nBecause it is not clear what the saturated model corresponding to a particular LinearMixedModel should be, negative twice the log-likelihood is called the objective.\n\nThis value is also accessible as the deviance but the user should bear in mind that this doesn't have all the properties of a deviance which is corrected for the saturated model. For example, it is not necessarily non-negative.\n\nobjective(fm1)\n\ndeviance(fm1)\n\nThe value optimized when fitting a GeneralizedLinearMixedModel is the Laplace approximation to the deviance or an adaptive Gauss-Hermite evaluation.\n\nMixedModels.deviance!(gm1)","category":"section"},{"location":"constructors/#Fixed-effects-parameter-estimates","page":"Model constructors","title":"Fixed-effects parameter estimates","text":"The coef and fixef extractors both return the maximum likelihood estimates of the fixed-effects coefficients. They differ in their behavior in the rank-deficient case. The associated coefnames and fixefnames return the corresponding coefficient names.\n\ncoef(fm1)\ncoefnames(fm1)\n\nfixef(fm1)\nfixefnames(fm1)\n\nAn alternative extractor for the fixed-effects coefficient is the β property. Properties whose names are Greek letters usually have an alternative spelling, which is the name of the Greek letter.\n\nfm1.β\n\nfm1.beta\n\ngm1.β\n\nA full list of property names is returned by propertynames\n\npropertynames(fm1)\n\npropertynames(gm1)\n\nThe variance-covariance matrix of the fixed-effects coefficients is returned by\n\nvcov(fm2)\n\nvcov(gm1)\n\nThe standard errors are the square roots of the diagonal elements of the estimated variance-covariance matrix of the fixed-effects coefficient estimators.\n\nstderror(fm2)\n\nstderror(gm1)\n\nFinally, the coeftable generic produces a table of coefficient estimates, their standard errors, and their ratio. The p-values quoted here should be regarded as approximations.\n\ncoeftable(fm2)\nDisplayAs.Text(ans) # hide","category":"section"},{"location":"constructors/#Covariance-parameter-estimates","page":"Model constructors","title":"Covariance parameter estimates","text":"The covariance parameters estimates, in the form shown in the model summary, are a VarCorr object\n\nVarCorr(fm2)\nDisplayAs.Text(ans) # hide\n\nVarCorr(gm1)\nDisplayAs.Text(ans) # hide\n\nIndividual components are returned by other extractors\n\nvarest(fm2)\n\nsdest(fm2)\n\nfm2.σ","category":"section"},{"location":"constructors/#Conditional-modes-of-the-random-effects","page":"Model constructors","title":"Conditional modes of the random effects","text":"The ranef extractor\n\nranef(fm1)\n\nfm1.b\n\nreturns the conditional modes of the random effects given the observed data. That is, these are the values that maximize the conditional density of the random effects given the observed data. For a LinearMixedModel these are also the conditional means.\n\nThese are sometimes called the best linear unbiased predictors or BLUPs but that name is not particularly meaningful.\n\nAt a superficial level these can be considered as the \"estimates\" of the random effects, with a bit of hand waving, but pursuing this analogy too far usually results in confusion.\n\nTo obtain tables associating the values of the conditional modes with the levels of the grouping factor, use\n\nas in\n\nDataFrame(only(raneftables(fm1)))\n\nThe corresponding conditional variances are returned by\n\ncondVar(fm1)","category":"section"},{"location":"constructors/#Case-wise-diagnostics-and-residual-degrees-of-freedom","page":"Model constructors","title":"Case-wise diagnostics and residual degrees of freedom","text":"The leverage values\n\nleverage(fm1)\n\nare used in diagnostics for linear regression models to determine cases that exert a strong influence on their own predicted response.\n\nThe documentation refers to a \"projection\". For a linear model without random effects the fitted values are obtained by orthogonal projection of the response onto the column span of the model matrix and the sum of the leverage values is the dimension of this column span. That is, the sum of the leverage values is the rank of the model matrix and n - sum(leverage(m)) is the degrees of freedom for residuals. The sum of the leverage values is also the trace of the so-called \"hat\" matrix, H. (The name \"hat matrix\" reflects the fact that hatmathbfy = mathbfH mathbfy.  That is, H puts a hat on y.)\n\nFor a linear mixed model the sum of the leverage values will be between p, the rank of the fixed-effects model matrix, and p + q where q is the total number of random effects. This number does not represent a dimension (or \"degrees of freedom\") of a linear subspace of all possible fitted values because the projection is not an orthogonal projection. Nevertheless, it is a reasonable measure of the effective degrees of freedom of the model and n - sum(leverage(m)) can be considered the effective residual degrees of freedom.\n\nFor model fm1 the dimensions are\n\nn, p, q, k = size(fm1)\n\nwhich implies that the sum of the leverage values should be in the range [1, 7]. The actual value is\n\nsum(leverage(fm1))\n\nFor model fm2 the dimensions are\n\nn, p, q, k = size(fm2)\n\nproviding a range of [2, 38] for the effective degrees of freedom for the model. The observed value is\n\nsum(leverage(fm2))\n\nWhen a model converges to a singular covariance, such as\n\nfm3 = fit(MixedModel, @formula(yield ~ 1+(1|batch)), MixedModelsDatasets.dataset(:dyestuff2))\nDisplayAs.Text(ans) # hide\n\nthe effective degrees of freedom is the lower bound.\n\nsum(leverage(fm3))\n\nModels for which the estimates of the variances of the random effects are large relative to the residual variance have effective degrees of freedom close to the upper bound.\n\nfm4 = fit(MixedModel, @formula(diameter ~ 1+(1|plate)+(1|sample)),\n    MixedModelsDatasets.dataset(:penicillin))\nDisplayAs.Text(ans) # hide\n\nsum(leverage(fm4))\n\nAlso, a model fit by the REML criterion generally has larger estimates of the variance components and hence a larger effective degrees of freedom.\n\nfm4r = fit(MixedModel, @formula(diameter ~ 1+(1|plate)+(1|sample)),\n    MixedModelsDatasets.dataset(:penicillin), REML=true)\nDisplayAs.Text(ans) # hide\n\nsum(leverage(fm4r))","category":"section"},{"location":"constructors/#StatsModels.@formula","page":"Model constructors","title":"StatsModels.@formula","text":"@formula(ex)\n\nCapture and parse a formula expression as a FormulaTerm struct.\n\nA formula is an abstract specification of a dependence between left-hand and right-hand side variables as in, e.g., a regression model.  Each side specifies at a high level how tabular data is to be converted to a numerical matrix suitable for modeling.  This specification looks something like Julia code, is represented as a Julia Expr, but uses special syntax.  The @formula macro takes an expression like y ~ 1 + a*b, transforms it according to the formula syntax rules into a lowered form (like y ~ 1 + a + b + a&b), and constructs a FormulaTerm struct which captures the original expression, the lowered expression, and the left- and right-hand-side.\n\nOperators that have special interpretations in this syntax are\n\n~ is the formula separator, where it is a binary operator (the first argument is the left-hand side, and the second is the right-hand side.\n+ concatenates variables as columns when generating a model matrix.\n& represents an interaction between two or more variables, which corresponds to a row-wise kronecker product of the individual terms (or element-wise product if all terms involved are continuous/scalar).\n* expands to all main effects and interactions: a*b is equivalent to a+b+a&b, a*b*c to a+b+c+a&b+a&c+b&c+a&b&c, etc.\n1, 0, and -1 indicate the presence (for 1) or absence (for 0 and -1) of an intercept column.\n\nThe rules that are applied are\n\nThe associative rule (un-nests nested calls to +, &, and *).\nThe distributive rule (interactions & distribute over concatenation +).\nThe * rule expands a*b to a+b+a&b (recursively).\nSubtraction is converted to addition and negation, so x-1 becomes x + -1 (applies only to subtraction of literal 1).\nSingle-argument & calls are stripped, so &(x) becomes the main effect x.\n\n\n\n\n\n","category":"macro"},{"location":"constructors/#StatsAPI.loglikelihood","page":"Model constructors","title":"StatsAPI.loglikelihood","text":"loglikelihood(model::StatisticalModel)\nloglikelihood(model::StatisticalModel, observation)\n\nReturn the log-likelihood of the model.\n\nWith an observation argument, return the contribution of observation to the log-likelihood of model.\n\nIf observation is a Colon, return a vector of each observation's contribution to the log-likelihood of the model. In other words, this is the vector of the pointwise log-likelihood contributions.\n\nIn general, sum(loglikehood(model, :)) == loglikelihood(model).\n\n\n\n\n\n","category":"function"},{"location":"constructors/#StatsAPI.aic","page":"Model constructors","title":"StatsAPI.aic","text":"aic(model::StatisticalModel)\n\nAkaike's Information Criterion, defined as -2 log L + 2k, with L the likelihood of the model, and k its number of consumed degrees of freedom (as returned by dof).\n\n\n\n\n\n","category":"function"},{"location":"constructors/#StatsAPI.bic","page":"Model constructors","title":"StatsAPI.bic","text":"bic(model::StatisticalModel)\n\nBayesian Information Criterion, defined as -2 log L + k log n, with L the likelihood of the model,  k its number of consumed degrees of freedom (as returned by dof), and n the number of observations (as returned by nobs).\n\n\n\n\n\n","category":"function"},{"location":"constructors/#StatsAPI.dof","page":"Model constructors","title":"StatsAPI.dof","text":"dof(model::StatisticalModel)\n\nReturn the number of degrees of freedom consumed in the model, including when applicable the intercept and the distribution's dispersion parameter.\n\n\n\n\n\n","category":"function"},{"location":"constructors/#StatsAPI.nobs","page":"Model constructors","title":"StatsAPI.nobs","text":"nobs(model::StatisticalModel)\n\nReturn the number of independent observations on which the model was fitted. Be careful when using this information, as the definition of an independent observation may vary depending on the model, on the format used to pass the data, on the sampling plan (if specified), etc.\n\n\n\n\n\n","category":"function"},{"location":"constructors/#StatsAPI.deviance-Tuple{StatisticalModel}","page":"Model constructors","title":"StatsAPI.deviance","text":"deviance(m::GeneralizedLinearMixedModel{T}, nAGQ=1)::T where {T}\n\nReturn the deviance of m evaluated by the Laplace approximation (nAGQ=1) or nAGQ-point adaptive Gauss-Hermite quadrature.\n\nIf the distribution D does not have a scale parameter the Laplace approximation is the squared length of the conditional modes, u, plus the determinant of ΛZWZΛ + I, plus the sum of the squared deviance residuals.\n\n\n\n\n\n","category":"method"},{"location":"constructors/#MixedModels.objective","page":"Model constructors","title":"MixedModels.objective","text":"objective(m::LinearMixedModel)\n\nReturn negative twice the log-likelihood of model m\n\n\n\n\n\n","category":"function"},{"location":"constructors/#MixedModels.deviance!","page":"Model constructors","title":"MixedModels.deviance!","text":"deviance!(m::GeneralizedLinearMixedModel, nAGQ=1)\n\nUpdate m.η, m.μ, etc., install the working response and working weights in m.LMM, update m.LMM.A and m.LMM.R, then evaluate the deviance.\n\n\n\n\n\n","category":"function"},{"location":"constructors/#StatsAPI.coef","page":"Model constructors","title":"StatsAPI.coef","text":"coef(model::StatisticalModel)\n\nReturn the coefficients of the model.\n\n\n\n\n\n","category":"function"},{"location":"constructors/#StatsAPI.coefnames","page":"Model constructors","title":"StatsAPI.coefnames","text":"coefnames(model::StatisticalModel)\n\nReturn the names of the coefficients.\n\n\n\n\n\n","category":"function"},{"location":"constructors/#MixedModels.fixef","page":"Model constructors","title":"MixedModels.fixef","text":"fixef(m::MixedModel)\n\nReturn the fixed-effects parameter vector estimate of m.\n\nIn the rank-deficient case the truncated parameter vector, of length rank(m) is returned. This is unlike coef which always returns a vector whose length matches the number of columns in X.\n\n\n\n\n\n","category":"function"},{"location":"constructors/#MixedModels.fixefnames","page":"Model constructors","title":"MixedModels.fixefnames","text":"fixefnames(m::MixedModel)\n\nReturn a (permuted and truncated in the rank-deficient case) vector of coefficient names.\n\n\n\n\n\n","category":"function"},{"location":"constructors/#StatsAPI.vcov","page":"Model constructors","title":"StatsAPI.vcov","text":"vcov(model::StatisticalModel)\n\nReturn the variance-covariance matrix for the coefficients of the model.\n\n\n\n\n\n","category":"function"},{"location":"constructors/#StatsAPI.stderror","page":"Model constructors","title":"StatsAPI.stderror","text":"stderror(model::StatisticalModel)\n\nReturn the standard errors for the coefficients of the model.\n\n\n\n\n\n","category":"function"},{"location":"constructors/#StatsAPI.coeftable","page":"Model constructors","title":"StatsAPI.coeftable","text":"coeftable(model::StatisticalModel; level::Real=0.95)\n\nReturn a table with coefficients and related statistics of the model. level determines the level for confidence intervals (by default, 95%).\n\nThe returned CoefTable object implements the Tables.jl interface, and can be converted e.g. to a DataFrame via using DataFrames; DataFrame(coeftable(model)).\n\n\n\n\n\n","category":"function"},{"location":"constructors/#MixedModels.varest","page":"Model constructors","title":"MixedModels.varest","text":"varest(m::LinearMixedModel)\n\nReturns the estimate of σ², the variance of the conditional distribution of Y given B.\n\n\n\n\n\nvarest(m::GeneralizedLinearMixedModel)\n\nReturns the estimate of ϕ², the variance of the conditional distribution of Y given B.\n\nFor models with a dispersion parameter ϕ, this is simply ϕ². For models without a dispersion parameter, this value is missing. This differs from disperion, which returns 1 for models without a dispersion parameter.\n\nFor Gaussian models, this parameter is often called σ².\n\n\n\n\n\n","category":"function"},{"location":"constructors/#MixedModels.sdest","page":"Model constructors","title":"MixedModels.sdest","text":"sdest(m::LinearMixedModel)\n\nReturn the estimate of σ, the standard deviation of the per-observation noise.\n\n\n\n\n\nsdest(m::GeneralizedLinearMixedModel)\n\nReturn the estimate of the dispersion, i.e. the standard deviation of the per-observation noise.\n\nFor models with a dispersion parameter ϕ, this is simply ϕ. For models without a dispersion parameter, this value is missing. This differs from disperion, which returns 1 for models without a dispersion parameter.\n\nFor Gaussian models, this parameter is often called σ.\n\n\n\n\n\n","category":"function"},{"location":"constructors/#MixedModels.ranef","page":"Model constructors","title":"MixedModels.ranef","text":"ranef(m::LinearMixedModel; uscale=false)\n\nReturn, as a Vector{Matrix{T}}, the conditional modes of the random effects in model m.\n\nIf uscale is true the random effects are on the spherical (i.e. u) scale, otherwise on the original scale.\n\nFor a named variant, see raneftables.\n\n\n\n\n\n","category":"function"},{"location":"constructors/#MixedModels.raneftables","page":"Model constructors","title":"MixedModels.raneftables","text":"raneftables(m::MixedModel; uscale = false)\n\nReturn the conditional means of the random effects as a NamedTuple of Tables.jl-compliant tables.\n\nnote: Note\nThe API guarantee is only that the NamedTuple contains Tables.jl tables and not on the particular concrete type of each table.\n\n\n\n\n\n","category":"function"},{"location":"constructors/#MixedModels.condVar","page":"Model constructors","title":"MixedModels.condVar","text":"condVar(m::LinearMixedModel)\n\nReturn the conditional variances matrices of the random effects.\n\nThe random effects are returned by ranef as a vector of length k, where k is the number of random effects terms.  The ith element is a matrix of size vᵢ × ℓᵢ  where vᵢ is the size of the vector-valued random effects for each of the ℓᵢ levels of the grouping factor.  Technically those values are the modes of the conditional distribution of the random effects given the observed data.\n\nThis function returns an array of k three dimensional arrays, where the ith array is of size vᵢ × vᵢ × ℓᵢ.  These are the diagonal blocks from the conditional variance-covariance matrix,\n\ns² Λ(Λ'Z'ZΛ + I)⁻¹Λ'\n\n\n\n\n\n","category":"function"},{"location":"constructors/#StatsAPI.leverage","page":"Model constructors","title":"StatsAPI.leverage","text":"leverage(model::RegressionModel)\n\nReturn the diagonal of the projection matrix of the model.\n\n\n\n\n\n","category":"function"},{"location":"benchmarks/#Benchmark-Report-for-*/home/bates/.julia/packages/MixedModels/dn0WY/src/MixedModels.jl*","page":"Benchmark Report for /home/bates/.julia/packages/MixedModels/dn0WY/src/MixedModels.jl","title":"Benchmark Report for /home/bates/.julia/packages/MixedModels/dn0WY/src/MixedModels.jl","text":"","category":"section"},{"location":"benchmarks/#Job-Properties","page":"Benchmark Report for /home/bates/.julia/packages/MixedModels/dn0WY/src/MixedModels.jl","title":"Job Properties","text":"Time of benchmark: 2 Oct 2018 - 13:42\nPackage commit: non gi\nJulia commit: 5d4eac\nJulia command flags: None\nEnvironment variables: None","category":"section"},{"location":"benchmarks/#Results","page":"Benchmark Report for /home/bates/.julia/packages/MixedModels/dn0WY/src/MixedModels.jl","title":"Results","text":"Below is a table of this job's results, obtained by running the benchmarks. The values listed in the ID column have the structure [parent_group, child_group, ..., key], and can be used to index into the BaseBenchmarks suite to retrieve the corresponding benchmarks. The percentages accompanying time and memory values in the below table are noise tolerances. The \"true\" time/memory value for a given benchmark is expected to fall within this percentage of the reported value. An empty cell means that the value was zero.\n\nID time GC time memory allocations\n`[\"crossed\", \"Assay:1+A+B*C+(1 G)+(1 H)\"]` 2.943 ms (5%) \n`[\"crossed\", \"Demand:1+U+V+W+X+(1 G)+(1 H)\"]` 2.775 ms (5%) \n`[\"crossed\", \"InstEval:1+A*I+(1 G)+(1 H)\"]` 1.247 s (5%) 114.131 ms\n`[\"crossed\", \"InstEval:1+A+(1 G)+(1 H)+(1 I)\"]` 1.999 s (5%)\n`[\"crossed\", \"Penicillin:1+(1 G)+(1 H)\"]` 2.697 ms (5%) \n`[\"crossed\", \"ScotsSec:1+A+U+V+(1 G)+(1 H)\"]` 4.833 ms (5%) \n`[\"crossed\", \"dialectNL:1+A+T+U+V+W+X+(1 G)+(1 H)+(1 I)\"]` 416.892 ms (5%)\n`[\"crossed\", \"egsingle:1+A+U+V+(1 G)+(1 H)\"]` 31.421 ms (5%) 3.427 ms\n`[\"crossed\", \"ml1m:1+(1 G)+(1 H)\"]` 36.714 s (5%) 225.872 ms\n`[\"crossed\", \"paulsim:1+S+T+U+(1 H)+(1 G)\"]` 14.097 ms (5%) \n`[\"crossedvector\", \"bs10:1+U+V+W+((1+U+V+W) G)+((1+U+V+W) H)\"]` 165.171 ms (5%) 3.149 ms\n`[\"crossedvector\", \"d3:1+U+((1+U) G)+((1+U) H)+((1+U) I)\"]` 49.023 s (5%)\n`[\"crossedvector\", \"d3:1+U+(1 G)+(1 H)+(1 I)\"]` 299.348 ms (5%)\n`[\"crossedvector\", \"gb12:1+S+T+U+V+W+X+Z+((1+S+U+W) G)+((1+S+T+V) H)\"]` 134.101 ms (5%) \n`[\"crossedvector\", \"kb07:1+S+T+U+V+W+X+Z+((1+S+T+U+V+W+X+Z) G)+((1+S+T+U+V+W+X+Z) H)\"]` 3.488 s (5%) 16.508 ms\n`[\"crossedvector\", \"kb07:1+S+T+U+V+W+X+Z+(1 G)+((0+S) G)+((0+T) G)+((0+U) G)+((0+V)\n`[\"nested\", \"Animal:1+(1 G)+(1 H)\"]` 1.261 ms (5%) \n`[\"nested\", \"Chem97:1+(1 G)+(1 H)\"]` 58.460 ms (5%) 6.975 ms\n`[\"nested\", \"Chem97:1+U+(1 G)+(1 H)\"]` 59.353 ms (5%) 7.019 ms\n`[\"nested\", \"Genetics:1+A+(1 G)+(1 H)\"]` 2.062 ms (5%) \n`[\"nested\", \"Pastes:1+(1 G)+(1 H)\"]` 2.298 ms (5%) \n`[\"nested\", \"Semi2:1+A+(1 G)+(1 H)\"]` 2.309 ms (5%) \n`[\"simplescalar\", \"Alfalfa:1+A*B+(1 G)\"]` 1.210 ms (5%)  208.80 KiB (1%)\n`[\"simplescalar\", \"Alfalfa:1+A+B+(1 G)\"]` 1.021 ms (5%)  168.47 KiB (1%)\n`[\"simplescalar\", \"AvgDailyGain:1+A*U+(1 G)\"]` 1.287 ms (5%)  193.33 KiB (1%)\n`[\"simplescalar\", \"AvgDailyGain:1+A+U+(1 G)\"]` 1.144 ms (5%)  169.59 KiB (1%)\n`[\"simplescalar\", \"BIB:1+A*U+(1 G)\"]` 1.574 ms (5%)  222.20 KiB (1%)\n`[\"simplescalar\", \"BIB:1+A+U+(1 G)\"]` 1.171 ms (5%)  171.31 KiB (1%)\n`[\"simplescalar\", \"Bond:1+A+(1 G)\"]` 958.770 μs (5%)  141.25 KiB (1%)\n`[\"simplescalar\", \"Cultivation:1+A*B+(1 G)\"]` 1.089 ms (5%)  173.38 KiB (1%)\n`[\"simplescalar\", \"Cultivation:1+A+(1 G)\"]` 1.138 ms (5%)  162.14 KiB (1%)\n`[\"simplescalar\", \"Cultivation:1+A+B+(1 G)\"]` 1.147 ms (5%)  173.47 KiB (1%)\n`[\"simplescalar\", \"Dyestuff2:1+(1 G)\"]` 830.840 μs (5%)  105.20 KiB (1%)\n`[\"simplescalar\", \"Dyestuff:1+(1 G)\"]` 974.091 μs (5%)  120.86 KiB (1%)\n`[\"simplescalar\", \"Exam:1+A*U+B+(1 G)\"]` 2.250 ms (5%)  1.17 MiB (1%)\n`[\"simplescalar\", \"Exam:1+A+B+U+(1 G)\"]` 2.133 ms (5%)  1.03 MiB (1%)\n`[\"simplescalar\", \"Gasoline:1+U+(1 G)\"]` 1.164 ms (5%)  162.03 KiB (1%)\n`[\"simplescalar\", \"Hsb82:1+A+B+C+U+(1 G)\"]` 3.048 ms (5%)  2.12 MiB (1%)\n`[\"simplescalar\", \"IncBlk:1+A+U+V+W+Z+(1 G)\"]` 1.226 ms (5%)  208.83 KiB (1%)\n`[\"simplescalar\", \"Mississippi:1+A+(1 G)\"]` 980.968 μs (5%)  145.75 KiB (1%)\n`[\"simplescalar\", \"PBIB:1+A+(1 G)\"]` 1.509 ms (5%)  234.47 KiB (1%)\n`[\"simplescalar\", \"Rail:1+(1 G)\"]` 1.251 ms (5%)  151.34 KiB (1%)\n`[\"simplescalar\", \"Semiconductor:1+A*B+(1 G)\"]` 1.313 ms (5%)  222.95 KiB (1%)\n`[\"simplescalar\", \"TeachingII:1+A+T+U+V+W+X+Z+(1 G)\"]` 1.483 ms (5%)  284.53 KiB (1%)\n`[\"simplescalar\", \"cake:1+A*B+(1 G)\"]` 1.606 ms (5%)  412.83 KiB (1%)\n`[\"simplescalar\", \"ergoStool:1+A+(1 G)\"]` 1.057 ms (5%)  155.59 KiB (1%)\n`[\"singlevector\", \"Early:1+U+U&A+((1+U) G)\"]` 20.373 ms (5%)  3.47 MiB (1%)\n`[\"singlevector\", \"HR:1+A*U+V+((1+U) G)\"]` 5.183 ms (5%)  915.00 KiB (1%)\n`[\"singlevector\", \"Oxboys:1+U+((1+U) G)\"]` 13.207 ms (5%)  1.93 MiB (1%)\n`[\"singlevector\", \"SIMS:1+U+((1+U) G)\"]` 61.675 ms (5%)  12.86 MiB (1%)\n`[\"singlevector\", \"WWheat:1+U+((1+U) G)\"]` 7.311 ms (5%)  902.31 KiB (1%)\n`[\"singlevector\", \"Weights:1+A*U+((1+U) G)\"]` 18.303 ms (5%)  3.20 MiB (1%)\n`[\"singlevector\", \"sleepstudy:1+U+((1+U) G)\"]` 4.829 ms (5%)  797.48 KiB (1%)\n`[\"singlevector\", \"sleepstudy:1+U+(1 G)+((0+U) G)\"]` 3.219 ms (5%) ","category":"section"},{"location":"benchmarks/#Benchmark-Group-List","page":"Benchmark Report for /home/bates/.julia/packages/MixedModels/dn0WY/src/MixedModels.jl","title":"Benchmark Group List","text":"Here's a list of all the benchmark groups executed by this job:\n\n[\"crossed\"]\n[\"crossedvector\"]\n[\"nested\"]\n[\"simplescalar\"]\n[\"singlevector\"]","category":"section"},{"location":"benchmarks/#Julia-versioninfo","page":"Benchmark Report for /home/bates/.julia/packages/MixedModels/dn0WY/src/MixedModels.jl","title":"Julia versioninfo","text":"Julia Version 1.0.0\nCommit 5d4eaca0c9 (2018-08-08 20:58 UTC)\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n      Ubuntu 18.04.1 LTS\n  uname: Linux 4.15.0-36-generic #39-Ubuntu SMP Mon Sep 24 16:19:09 UTC 2018 x86_64 x86_64\n  CPU: Intel(R) Core(TM) i5-3570 CPU @ 3.40GHz: \n              speed         user         nice          sys         idle          irq\n       #1  1690 MHz     140498 s        134 s      18382 s    1495130 s          0 s\n       #2  2513 MHz     131505 s         16 s      18277 s    1504212 s          0 s\n       #3  1900 MHz     145131 s        581 s      18892 s    1485409 s          0 s\n       #4  1682 MHz     190751 s         38 s      17941 s    1445446 s          0 s\n       \n  Memory: 15.554645538330078 GB (10502.1171875 MB free)\n  Uptime: 16578.0 sec\n  Load Avg:  1.4091796875  2.07080078125  1.63037109375\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-6.0.0 (ORCJIT, ivybridge)","category":"section"},{"location":"derivatives/#Gradient-and-Hessian-computation","page":"Gradient and Hessian computation","title":"Gradient and Hessian computation","text":"Experimental support for computing the gradient and the Hessian of the objective function (i.e. negative twice the profiled log likelihood) via ForwardDiff.jl and FiniteDiff.jl are provided as package extensions.","category":"section"},{"location":"derivatives/#via-ForwardDiff.jl","page":"Gradient and Hessian computation","title":"via ForwardDiff.jl","text":"The core functionality is provided by defining appropriate methods for ForwardDiff.gradient and ForwardDiff.hessian:","category":"section"},{"location":"derivatives/#Exact-zero-at-optimum-for-trivial-models","page":"Gradient and Hessian computation","title":"Exact zero at optimum for trivial models","text":"using MixedModels, MixedModelsDatasets, ForwardDiff\nusing DisplayAs # hide\nfm1 = lmm(@formula(yield ~ 1 + (1|batch)), MixedModelsDatasets.dataset(:dyestuff2))\nDisplayAs.Text(ans) # hide\n\nForwardDiff.gradient(fm1)\n\nForwardDiff.hessian(fm1)","category":"section"},{"location":"derivatives/#Approximate-zero-at-optimum-for-non-trivial-models","page":"Gradient and Hessian computation","title":"Approximate zero at optimum for non trivial models","text":"fm2 = lmm(@formula(reaction ~ 1 + days + (1+days|subj)), MixedModelsDatasets.dataset(:sleepstudy))\nDisplayAs.Text(ans) # hide\n\nForwardDiff.gradient(fm2)\n\nForwardDiff.hessian(fm2)","category":"section"},{"location":"derivatives/#via-FiniteDiff.jl","page":"Gradient and Hessian computation","title":"via FiniteDiff.jl","text":"The core functionality is provided by defining appropriate methods for FiniteDiff.finite_difference_gradient and FiniteDiff.finite_difference_hessian:\n\nusing FiniteDiff\nFiniteDiff.finite_difference_gradient(fm2)\n\nFiniteDiff.finite_difference_hessian(fm2)","category":"section"},{"location":"derivatives/#ForwardDiff.gradient-Union{Tuple{T}, Tuple{LinearMixedModel{T}, Vector{T}}} where T","page":"Gradient and Hessian computation","title":"ForwardDiff.gradient","text":"ForwardDiff.gradient(f, x::AbstractArray, cfg::GradientConfig = GradientConfig(f, x), check=Val{true}())\n\nReturn ∇f evaluated at x, assuming f is called as f(x). The array ∇f has the same shape as x, and its elements are ∇f[j, k, ...] = ∂f/∂x[j, k, ...].\n\nThis method assumes that isa(f(x), Real).\n\nSet check to Val{false}() to disable tag checking. This can lead to perturbation confusion, so should be used with care.\n\n\n\n\n\nForwardDiff.gradient(model::LinearMixedModel)\n\nEvaluate the gradient of the objective function at the currently fitted parameter values.\n\nwarning: Large allocations\nMost of MixedModels.jl relies strongly on in-place methods in order to minimize the amount of memory allocated. In addition to reducing the memory burden (especially for large models), this practice generally speeds up evaluation of the objective. In-place methods, however, generally do not play well with automatic differentiation. For the automatic differentiation support provided here, the developers instead implemented alternative, out-of-place methods. These will generally be slower and much more memory intensive, so use of this functionality is not recommended for large models.\n\nwarning: ForwardDiff.jl support is experimental.\nCompatibility with ForwardDiff.jl is experimental. The precise structure, including function names and method definitions, is subject to change without being considered a breaking change. In particular, the exact set of parameters included is subject to change. The θ parameter is always included, but whether σ and/or the fixed effects should be included is currently still being decided.\n\n\n\n\n\n","category":"method"},{"location":"derivatives/#ForwardDiff.hessian-Union{Tuple{T}, Tuple{LinearMixedModel{T}, Vector{T}}} where T","page":"Gradient and Hessian computation","title":"ForwardDiff.hessian","text":"ForwardDiff.hessian(f, x::AbstractArray, cfg::HessianConfig = HessianConfig(f, x), check=Val{true}())\n\nReturn H(f) (i.e. J(∇(f))) evaluated at x, assuming f is called as f(x).\n\nThis method assumes that isa(f(x), Real).\n\nSet check to Val{false}() to disable tag checking. This can lead to perturbation confusion, so should be used with care.\n\n\n\n\n\nForwardDiff.hessian(model::LinearMixedModel)\n\nEvaluate the Hessian of the objective function at the currently fitted parameter values.\n\nwarning: Large allocations\nMost of MixedModels.jl relies strongly on in-place methods in order to minimize the amount of memory allocated. In addition to reducing the memory burden (especially for large models), this practice generally speeds up evaluation of the objective. In-place methods, however, generally do not play well with automatic differentiation. For the automatic differentiation support provided here, the developers instead implemented alternative, out-of-place methods. These will generally be slower and much more memory intensive, so use of this functionality is not recommended for large models.\n\nwarning: ForwardDiff.jl support is experimental.\nCompatibility with ForwardDiff.jl is experimental. The precise structure, including function names and method definitions, is subject to change without being considered a breaking change. In particular, the exact set of parameters included is subject to change. The θ parameter is always included, but whether σ and/or the fixed effects should be included is currently still being decided.\n\n\n\n\n\n","category":"method"},{"location":"derivatives/#FiniteDiff.finite_difference_gradient-Union{Tuple{T}, Tuple{LinearMixedModel{T}, Vector{T}}} where T","page":"Gradient and Hessian computation","title":"FiniteDiff.finite_difference_gradient","text":"FiniteDiff.finite_difference_gradient(model::LinearMixedModel, args...; kwargs...)\n\nEvaluate the gradient of the objective function at the currently fitted parameter values.\n\nwarning: FiniteDiff.jl support is experimental.\nCompatibility with FiniteDiff.jl is experimental. The precise structure, including function names and method definitions, is subject to change without being considered a breaking change. In particular, the exact set of parameters included is subject to change. The θ parameter is always included, but whether σ and/or the fixed effects should be included is currently still being decided.\n\n\n\n\n\n","category":"method"},{"location":"derivatives/#FiniteDiff.finite_difference_hessian-Union{Tuple{T}, Tuple{LinearMixedModel{T}, Vector{T}}} where T","page":"Gradient and Hessian computation","title":"FiniteDiff.finite_difference_hessian","text":"FiniteDiff.finite_difference_hessian(model::LinearMixedModel, args...; kwargs...)\n\nEvaluate the Hessian of the objective function at the currently fitted parameter values.\n\nwarning: FiniteDiff.jl support is experimental.\nCompatibility with FiniteDiff.jl is experimental. The precise structure, including function names and method definitions, is subject to change without being considered a breaking change. In particular, the exact set of parameters included is subject to change. The θ parameter is always included, but whether σ and/or the fixed effects should be included is currently still being decided.\n\n\n\n\n\n","category":"method"},{"location":"ecosystem/#Additional-Functionality-in-Other-Packages","page":"Additional Functionality in Other Packages","title":"Additional Functionality in Other Packages","text":"Several packages extend the functionality of MixedModels.jl, both in ways specific to mixed models and in ways applicable to more general regression models. In the following, we will use the models from the previous sections to showcase this functionality.\n\nusing MixedModels\nprogress = isinteractive()\n\ninsteval = MixedModels.dataset(\"insteval\")\nie1 = fit(MixedModel,\n          @formula(y ~ 1 + studage + lectage + service + (1|s) + (1|d) + (1|dept)),\n          insteval; progress)\n\n\nie2 = fit(MixedModel,\n          @formula(y ~ 1 + studage + lectage + service +\n                      (1 | s) +\n                      (1 + service | d) +\n                      (1 + service | dept)),\n          insteval; progress)\n\nsleepstudy = MixedModels.dataset(\"sleepstudy\")\nss1 = fit(MixedModel, @formula(reaction ~ 1 + days + (1|subj)), sleepstudy; progress)\n\nss2 = fit(MixedModel, @formula(reaction ~ 1 + days + (1 + days|subj)), sleepstudy; progress)\n\nusing DataFrames\ncontra = DataFrame(MixedModels.dataset(\"contra\"))\ncontra[!, :anych] .= contra[!, :livch] .!= \"0\"\ncontrasts = Dict(:livch => EffectsCoding(; base=\"0\"),\n                 :urban => HelmertCoding(),\n                 :anych => HelmertCoding())\ngm1 = fit(MixedModel,\n          @formula(use ~ 1 + urban + anych * age + abs2(age) + (1 | dist & urban)),\n          contra,\n          Bernoulli();\n          contrasts,\n          progress)","category":"section"},{"location":"ecosystem/#MixedModelsExtras.jl","page":"Additional Functionality in Other Packages","title":"MixedModelsExtras.jl","text":"https://palday.github.io/MixedModelsExtras.jl/v2\n\nMixedModelsExtras.jl is a collection of odds-and-ends that may be useful when working with mixed effects models, but which we do not want to include in MixedModels.jl at this time. Some functions may one day migrate to MixedModels.jl, when we are happy with their performance and interface (e.g. vif), but some are intentionally omitted from MixedModels.jl (e.g. r2, adjr2).\n\nusing MixedModelsExtras\n\nr2(ss2; conditional=true)\n\nr2(ss2; conditional=false)\n\nicc(ie2)\n\nicc(ie2, :dept)\n\nvif(ie1)\n\nDataFrame(; coef=fixefnames(ie1)[2:end], VIF=vif(ie1))\n\ngvif(ie1)\n\nDataFrame(; term=termnames(ie1)[2][2:end], GVIF=gvif(ie1))","category":"section"},{"location":"ecosystem/#RegressionFormulae.jl","page":"Additional Functionality in Other Packages","title":"RegressionFormulae.jl","text":"https://github.com/kleinschmidt/RegressionFormulae.jl\n\nRegressionFormulae.jl provides a few extensions to the somewhat more restricted variant of the Wilkinson-Roger notation found in Julia. In particular, it adds / for nested designs within the fixed effects and ^ for computing interactions only up to a certain order.\n\nusing RegressionFormulae\n\nfit(MixedModel,\n          @formula(y ~ 1 + service / (studage + lectage) +\n                      (1 | s) +\n                      (1 | d) +\n                      (1 | dept)),\n          insteval; progress)\n\nfit(MixedModel,\n          @formula(y ~ 1 + (studage + lectage + service)^2 +\n                      (1 | s) +\n                      (1 | d) +\n                      (1 | dept)),\n          insteval; progress)","category":"section"},{"location":"ecosystem/#BoxCox.jl","page":"Additional Functionality in Other Packages","title":"BoxCox.jl","text":"https://palday.github.io/BoxCox.jl/v0.3/\n\nBoxCox.jl implements a the Box-Cox transformation in an efficient way. Via package extensions, it supports specializations for MixedModels.jl and several plotting functions, but does not incur a dependency penalty for this functionality when MixedModels.jl or Makie.jl are not loaded.\n\nusing BoxCox\n\nbc = fit(BoxCoxTransformation, ss2)\n\nusing CairoMakie\nboxcoxplot(bc; conf_level=0.95)\n\nThe estimated λ is very close to -1, i.e. the reciprocal of reaction time, which has a natural interpretation as speed. In other words, the Box-Cox transformation suggests that we should consider modelling the sleepstudy data as speed (reaction per unit time) instead of reaction time:\n\nfit(MixedModel, @formula(1000 / reaction ~ 1 + days + (1 + days|subj)), sleepstudy)\n\n(We multiply by 1000 to get the responses per second instead of the responses per millisecond.)\n\ntip: Tip\nBoxCox.jl also works with classical linear models.","category":"section"},{"location":"ecosystem/#Effects.jl","page":"Additional Functionality in Other Packages","title":"Effects.jl","text":"https://beacon-biosignals.github.io/Effects.jl/v1.2/\n\nEffects.jl provides a convenient method to compute effects, i.e. predictions and associated prediction intervals computed at points on a reference grid. For models with a nonlinear link function, Effects.jl will also compute appropriate errors on the response scale based on the difference method.\n\nFor MixedModels.jl, the predictions are computed based on the fixed effects only.\n\nThe functionality of Effects.jl was inspired by the effects and emmeans packages in R and the methods within are based on @fox:effect:2003.\n\nusing Effects\n\ndesign = Dict(:age => -15:1:20,\n              :anych => [true, false])\n\neff_logit = effects(design, gm1; eff_col=\"use\", level=0.95)\n\neff_prob = effects(design, gm1; eff_col=\"use\", level=0.95, invlink=AutoInvLink())\n\nEffects are particularly nice for visualizing the model fit and its predictions.\n\nusing AlgebraOfGraphics # like ggplot2, but an algebra instead of a grammar\nusing CairoMakie\n\nplt1 = data(eff_logit) * mapping(:age; color=:anych) *\n      (mapping(:use) * visual(Lines) +\n       mapping(:lower, :upper) * visual(Band; alpha=0.3))\ndraw(plt1)\n\nplt2 = data(eff_prob) * mapping(:age; color=:anych) *\n      (mapping(:use) * visual(Lines) +\n       mapping(:lower, :upper) * visual(Band; alpha=0.3))\ndraw(plt2)\n\nusing Statistics: mean\ncontra_by_age = transform(contra,\n                          :age => ByRow(x -> round(Int, x)),\n                          :use => ByRow(==(\"Y\"));\n                          renamecols=false)\ncontra_by_age = combine(groupby(contra_by_age, [:age, :anych]),\n                        :use => mean => :use)\nplt3 = plt2 +\n       data(contra_by_age) *\n       mapping(:age, :use;\n               color=:anych => \"children\") * visual(Scatter)\n\ndraw(plt3;\n     axis=(; title=\"Estimated contraceptive use by age and children\",\n            limits=(nothing, (0, 1)) # ylim=0,1, xlim=auto\n            ))\n\nEffects and estimated marginal (least squares) means are closely related and partially concepts. Effects.jl provides convenience function emmeans and empairs for computing EM means and pairwise differences of EM means.\n\nemmeans(gm1)\n\nempairs(gm1; dof=Inf)\n\ntip: Tip\nEffects.jl will work with any package that supports the StatsAPI.jl-based RegressionModel interface.","category":"section"},{"location":"ecosystem/#StandardizedPredictors.jl","page":"Additional Functionality in Other Packages","title":"StandardizedPredictors.jl","text":"https://beacon-biosignals.github.io/StandardizedPredictors.jl/v1/\n\nStandardizedPredictors.jl provides a convenient way to express centering, scaling, and z-standardization as a \"contrast\" via the pseudo-contrasts Center, Scale, ZScore. Because these use the usual contrast machinery, they work well with any packages that use that machinery correctly (e.g. Effects.jl). The default behavior is to empirically compute the center and scale, but these can also be explicitly provided, either as a number or as a function (e.g. median to use the median for centering.)\n\nusing StandardizedPredictors\n\ncontrasts = Dict(:days => Center())\nfit(MixedModel,\n    @formula(reaction ~ 1 + days + (1 + days|subj)), sleepstudy;\n    contrasts)\n\ntip: Tip\nStandardizedPredictors.jl will work with any package that supports the StatsModels.jl-based @formula and contrast machinery.","category":"section"},{"location":"ecosystem/#RCall.jl-and-JellyMe4.jl","page":"Additional Functionality in Other Packages","title":"RCall.jl and JellyMe4.jl","text":"https://juliainterop.github.io/RCall.jl/stable/\n\nhttps://github.com/palday/JellyMe4.jl/\n\nRCall.jl provides a convenient interface for interoperability with R from Julia. JellyMe4.jl extends the functionality of RCall so that MixedModels.jl-fitted models and lme4-fitted models can be translated to each other. In practical terms, this means that you can enjoy the speed of Julia for model fitting, but use all the extra packages you love from R's larger ecosystem.\n\n<!– MixedModelsSerializtion.jl MixedModelsSim.jl –>","category":"section"},{"location":"formula_syntax/#Formula-syntax","page":"Formula syntax","title":"Formula syntax","text":"MixedModels.jl uses the variant of the Wilkinson-Rogers (1973) notation for models of (co)variance implemented by StatsModels.jl. Additionally, MixedModels.jl extends this syntax to use the pipe | as the grouping operator. Further extensions are provided by RegressionFormulae.jl, in particular the use of the slash / as the nesting operator and the use of the caret ^ to indicate main effects and interactions up to a specified order. Currently, MixedModels.jl loads RegressionFormulae.jl by default, though this may change in a future release. If you require specific functionality from RegressionFormulae.jl, it is best to load it directly so that you can control the version used.","category":"section"},{"location":"formula_syntax/#General-rules","page":"Formula syntax","title":"General rules","text":"\"Addition\" (+) indicates additive, i.e., main effects: a + b indicates main effects of a and b.\n\"Multiplication\" (*) indicates crossing: main effects and interactions between two terms: a * b indicates main effects of a and b as well as their interaction.\nUsual algebraic rules apply (associativity and distributivity):\n(a + b) * c is equivalent to a * c + b * c\na * b * c corresponds to main effects of a, b, and c, as well as all three two-way interactions and the three-way interaction.\nCategorical terms are expanded into the associated indicators/contrast variables. See the StatsModels.jl documentation on contrasts for more information.\nInteractions are expressed with the ampersand (&). (This is contrast to R, which uses the colon : for this operation.). a&b is the interaction of a and b. For categorical terms, appropriate combinations of indicators/contrast variables are generated.\nTilde (~) is used to separate response from predictors.\nThe intercept is indicated by 1.\ny ~ 1 + (a + b) * c is read as:\nThe response variable is y.\nThe model contains an intercept.\nThe model contains main effects of a, b, and c.\nThe model contains interactions between a and c and between b and c but not a and b.\nAn intercept is included by default, i.e. there is an implicit 1 + in every formula. The intercept may be suppressed by including a 0 + in the formula. (In contrast to R, the use of -1 is not supported.)","category":"section"},{"location":"formula_syntax/#MixedModels.jl-provided-extensions","page":"Formula syntax","title":"MixedModels.jl provided extensions","text":"The pipe operator (|) indicates grouping or blocking.\n(1 + a | subject) indicates \"by-subject random effects for the intercept and main effect a\".\nThis is in line with the usual statistical reading of | as \"conditional on\".","category":"section"},{"location":"formula_syntax/#RegressionFormulae.jl-provided-extensions","page":"Formula syntax","title":"RegressionFormulae.jl provided extensions","text":"\"Exponentiation\" (^) works like repeated multiplication and generates all multiplicative and additive terms up to the given order.\n(a + b + c)^2 generates a + b + c + a&b + a&c + b&c, but not a&b&c.\nThe presence of interaction terms within the base will result in redundant terms and is currently unsupported.\nfulldummy(a) assigns \"contrasts\" to a that include all indicator columns (dummy variables) and an intercept column. The resulting overparameterization is generally useful in the fixed effects only as part of nesting.\nThe slash operator (/) indicates nesting:\na / b is read as \"b is nested within a\".\na / b expands to a + fulldummy(a) & b.\nIt is generally not necessary to specify nesting in the blocking variables, when the inner levels are unique across outer levels. In other words, in a study with children (C1, C2, etc. ) nested within schools (S1, S2, etc.),\nit is not necessary to specify the nesting when C1 identifies a unique child across schools. In other words, intercept-only random effects terms can be written as (1|C) + (1|S).\nit is necessary to specify the nesting when chid identifiers are re-used across schools, e.g. C1 refers to a child in S1 and a different child in S2. In this case, the nested syntax (1|S/C) expands to (1|S) + (1|S&C). The interaction term in the second blocking variable generates unique labels for each child across schools.","category":"section"},{"location":"formula_syntax/#Mixed-models-in-Wilkinson-Rogers-and-mathematical-notation","page":"Formula syntax","title":"Mixed models in Wilkinson-Rogers and mathematical notation","text":"Models fit with MixedModels.jl are generally linear mixed-effects models with unconstrained random effects covariance matrices and homoskedastic, normally distributed residuals. Under these assumptions, the model specification\n\nresponse ~ 1 + (age + sex) * education * n_children  + (1 | subject)\n\ncorresponds to the statistical model\n\nbeginalign*\nleft(Y mathcalB=bright) sim Nleft(Xbeta + Zb sigma^2 I right) \nmathcalB sim Nleft(0 Gright)\nendalign*\n\nfor which we wish to obtain the maximum-likelihood estimates for G and thus the fixed-effects beta.\n\nThe model contains no restrictions on G, except that it is positive semidefinite.\nThe response Y is the value of a given response.\nThe fixed-effects design matrix X consists of columns for\nthe intercept, age, sex, education, and number of children (contrast coded as appropriate)\nthe interaction of all lower order terms, excluding interactions between age and sex\nThe random-effects design matrix Z includes a column for\nthe intercept for each subject","category":"section"},{"location":"api/#API","page":"API","title":"API","text":"In addition to its own functionality, MixedModels.jl also implements extensive support for the StatsAPI.StatisticalModel and StatsAPI.RegressionModel API.","category":"section"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/#Exported-Functions","page":"API","title":"Exported Functions","text":"","category":"section"},{"location":"api/#Methods-from-StatsAPI.jl,-StatsBase.jl,-StatsModels.jl-and-GLM.jl","page":"API","title":"Methods from StatsAPI.jl, StatsBase.jl, StatsModels.jl and GLM.jl","text":"aic\naicc\nbic\ncoef\ncoefnames\ncoeftable\ndeviance\ndispersion\ndispersion_parameter\ndof\ndof_residual\nfit\nfit!\nfitted\nformula\nglmm\nisfitted\nislinear\nleverage\nlmm\nloglikelihood\nmeanresponse\nmodelmatrix\nmodel_response\nnobs\npredict\nresiduals\nresponse\nresponsename\nStatsModels.lrtest # not exported\nstd\nstderror\nvcov\nweights","category":"section"},{"location":"api/#MixedModels.jl-\"alternatives\"-and-extensions-to-StatsAPI-and-GLM-functions","page":"API","title":"MixedModels.jl \"alternatives\" and extensions to StatsAPI and GLM functions","text":"The following are MixedModels.jl-specific functions and not simply methods for functions defined in StatsAPI and GLM.jl.\n\ncoefpvalues\ncondVar\ncondVarTables\nfitted!\nfixef\nfixefnames\nlikelihoodratiotest # not exported\npwrss\nranef\nraneftables\nrefit!\nshortestcovint\nsdest\nsimulate\nsimulate!\nstderrror!\nvarest","category":"section"},{"location":"api/#Non-Exported-Functions-and-Constants","page":"API","title":"Non-Exported Functions and Constants","text":"Note that unless discussed elsewhere in the online documentation, non-exported functions and constants should be considered implementation details.","category":"section"},{"location":"api/#MixedModels.BlockDescription","page":"API","title":"MixedModels.BlockDescription","text":"BlockDescription\n\nDescription of blocks of A and L in a LinearMixedModel\n\nFields\n\nblknms: Vector{String} of block names\nblkrows: Vector{Int} of the number of rows in each block\nALtypes: Matrix{String} of datatypes for blocks in A and L.\n\nWhen a block in L is the same type as the corresponding block in A, it is described with a single name, such as Dense.  When the types differ the entry in ALtypes is of the form Diag/Dense, as determined by a shorttype method.\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedModels.BlockedSparse","page":"API","title":"MixedModels.BlockedSparse","text":"BlockedSparse{Tv,S,P}\n\nA SparseMatrixCSC whose nonzeros form blocks of rows or columns or both.\n\nMembers\n\ncscmat: SparseMatrixCSC{Tv, Int32} representation for general calculations\nnzasmat: nonzeros of cscmat as a dense matrix\ncolblkptr: pattern of blocks of columns\n\nThe only time these are created are as products of ReMats.\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedModels.FeMat","page":"API","title":"MixedModels.FeMat","text":"FeMat{T,S}\n\nA matrix and a (possibly) weighted copy of itself.\n\nTypically, an FeMat represents the fixed-effects model matrix with the response (y) concatenated as a final column.\n\nnote: Note\nFeMat is not the same as FeTerm.\n\nFields\n\nxy: original matrix, called xy b/c in practice this is hcat(fullrank(X), y)\nwtxy: (possibly) weighted copy of xy (shares storage with xy until weights are applied)\n\nUpon construction the xy and wtxy fields refer to the same matrix\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedModels.FeTerm","page":"API","title":"MixedModels.FeTerm","text":"FeTerm{T,S}\n\nTerm with an explicit, constant matrix representation\n\nTypically, an FeTerm represents the model matrix for the fixed effects.\n\nnote: Note\nFeTerm is not the same as FeMat!\n\nFields\n\nx: full model matrix\npiv: pivot Vector{Int} for moving linearly dependent columns to the right\nrank: computational rank of x\ncnames: vector of column names\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedModels.FeTerm-Tuple{SparseArrays.SparseMatrixCSC, AbstractVector{String}}","page":"API","title":"MixedModels.FeTerm","text":"FeTerm(X::SparseMatrixCSC, cnms)\n\nConvenience constructor for a sparse FeTerm assuming full rank, identity pivot and unit weights.\n\nNote: automatic rank deficiency handling may be added to this method in the future, as discussed in the vignette \"Rank deficiency in mixed-effects models\" for general FeTerm.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.FeTerm-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T","page":"API","title":"MixedModels.FeTerm","text":"FeTerm(X::AbstractMatrix, cnms)\n\nConvenience constructor for FeTerm that computes the rank and pivot with unit weights.\n\nSee the vignette \"Rank deficiency in mixed-effects models\" for more information on the computation of the rank and pivot.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.GaussHermiteNormalized","page":"API","title":"MixedModels.GaussHermiteNormalized","text":"GaussHermiteNormalized{K}\n\nA struct with 2 SVector{K,Float64} members\n\nz: abscissae for the K-point Gauss-Hermite quadrature rule on the Z scale\nwt: Gauss-Hermite weights normalized to sum to unity\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedModels.GeneralizedLinearMixedModel","page":"API","title":"MixedModels.GeneralizedLinearMixedModel","text":"GeneralizedLinearMixedModel\n\nGeneralized linear mixed-effects model representation\n\nFields\n\nLMM: a LinearMixedModel - the local approximation to the GLMM.\nβ: the pivoted and possibly truncated fixed-effects vector\nβ₀: similar to β. Used in the PIRLS algorithm if step-halving is needed.\nθ: covariance parameter vector\nb: similar to u, equivalent to broadcast!(*, b, LMM.Λ, u)\nu: a vector of matrices of random effects\nu₀: similar to u.  Used in the PIRLS algorithm if step-halving is needed.\nresp: a GlmResp object\nη: the linear predictor\nwt: vector of prior case weights, a value of T[] indicates equal weights.\n\nThe following fields are used in adaptive Gauss-Hermite quadrature, which applies only to models with a single random-effects term, in which case their lengths are the number of levels in the grouping factor for that term.  Otherwise they are zero-length vectors.\n\ndevc: vector of deviance components\ndevc0: vector of deviance components at offset of zero\nsd: approximate standard deviation of the conditional density\nmult: multiplier\n\nProperties\n\nIn addition to the fieldnames, the following names are also accessible through the . extractor\n\ntheta: synonym for θ\nbeta: synonym for β\nσ or sigma: common scale parameter (value is NaN for distributions without a scale parameter)\nformula, trms, A, L, and optsum: fields of the LMM field\nX: fixed-effects model matrix\ny: response vector\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedModels.Grouping","page":"API","title":"MixedModels.Grouping","text":"struct Grouping <: StatsModels.AbstractContrasts end\n\nA placeholder type to indicate that a categorical variable is only used for grouping and not for contrasts.  When creating a CategoricalTerm, this skips constructing the contrasts matrix which makes it robust to large numbers of levels, while still holding onto the vector of levels and constructing the level-to-index mapping (invindex field of the ContrastsMatrix.).\n\nNote that calling modelcols on a CategoricalTerm{Grouping} is an error.\n\nExamples\n\njulia> schema((; grp = string.(1:100_000)))\n# out-of-memory error\n\njulia> schema((; grp = string.(1:100_000)), Dict(:grp => Grouping()))\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedModels.LikelihoodRatioTest","page":"API","title":"MixedModels.LikelihoodRatioTest","text":"LikelihoodRatioTest{N}\n\nResult of MixedModels.likelihoodratiotest.\n\nThis struct wraps StatsModels.LRTestResult with a bit more metadata to enable a few additional show methods.\n\nFields\n\nformulas::NTuple{N, String}\nlrt::StatsModels.LRTestResult{N}\nlinear::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedModels.LinearMixedModel","page":"API","title":"MixedModels.LinearMixedModel","text":"LinearMixedModel(y, Xs, form, weights=[], σ=nothing, amalgamate=true)\n\nPrivate constructor for a LinearMixedModel.\n\nTo construct a model, you only need the response (y), already assembled model matrices (Xs), schematized formula (form) and weights (wts). Everything else in the structure can be derived from these quantities.\n\nnote: Note\nThis method is internal and experimental and so may change or disappear in a future release without being considered a breaking change.\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedModels.LinearMixedModel-2","page":"API","title":"MixedModels.LinearMixedModel","text":"LinearMixedModel\n\nLinear mixed-effects model representation\n\nFields\n\nformula: the formula for the model\nreterms: a Vector{AbstractReMat{T}} of random-effects terms.\nXymat: horizontal concatenation of a full-rank fixed-effects model matrix X and response y as an FeMat{T}\nfeterm: the fixed-effects model matrix as an FeTerm{T}\nsqrtwts: vector of square roots of the case weights.  Can be empty.\nparmap : Vector{NTuple{3,Int}} of (block, row, column) mapping of θ to λ\ndims : NamedTuple{(:n, :p, :nretrms),NTuple{3,Int}} of dimensions.  p is the rank of X, which may be smaller than size(X, 2).\nA: a Vector{AbstractMatrix} containing the row-major packed lower triangle of hcat(Z,X,y)'hcat(Z,X,y)\nL: the blocked lower Cholesky factor of Λ'AΛ+I in the same Vector representation as A\noptsum: an OptSummary object\n\nProperties\n\nθ or theta: the covariance parameter vector used to form λ\nβ or beta: the fixed-effects coefficient vector\nλ or lambda: a vector of lower triangular matrices repeated on the diagonal blocks of Λ\nσ or sigma: current value of the standard deviation of the per-observation noise\nb: random effects on the original scale, as a vector of matrices\nu: random effects on the orthogonal scale, as a vector of matrices\nX: the fixed-effects model matrix\ny: the response vector\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedModels.LinearMixedModel-Union{Tuple{T}, Tuple{AbstractArray, MixedModels.FeTerm{T}, AbstractVector{<:AbstractReMat{T}}, FormulaTerm}, Tuple{AbstractArray, MixedModels.FeTerm{T}, AbstractVector{<:AbstractReMat{T}}, FormulaTerm, Any}, Tuple{AbstractArray, MixedModels.FeTerm{T}, AbstractVector{<:AbstractReMat{T}}, FormulaTerm, Any, Any}, Tuple{AbstractArray, MixedModels.FeTerm{T}, AbstractVector{<:AbstractReMat{T}}, FormulaTerm, Any, Any, Any}} where T","page":"API","title":"MixedModels.LinearMixedModel","text":"LinearMixedModel(y, feterm, reterms, form, weights=[], σ=nothing; amalgamate=true)\n\nPrivate constructor for a LinearMixedModel given already assembled fixed and random effects.\n\nTo construct a model, you only need a vector of FeMats (the fixed-effects model matrix and response), a vector of AbstractReMat (the random-effects model matrices), the formula and the weights. Everything else in the structure can be derived from these quantities.\n\nnote: Note\nThis method is internal and experimental and so may change or disappear in a future release without being considered a breaking change.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.MixedModel","page":"API","title":"MixedModels.MixedModel","text":"MixedModel\n\nAbstract type for mixed models.  MixedModels.jl implements two subtypes: LinearMixedModel and GeneralizedLinearMixedModel.  See the documentation for each for more details.\n\nThis type is primarily used for dispatch in fit.  Without a distribution and link function specified, a LinearMixedModel will be fit.  When a distribution/link function is provided, a GeneralizedLinearModel is fit, unless that distribution is Normal and the link is IdentityLink, in which case the resulting GLMM would be equivalent to a LinearMixedModel anyway and so the simpler, equivalent LinearMixedModel will be fit instead.\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedModels.MixedModelBootstrap","page":"API","title":"MixedModels.MixedModelBootstrap","text":"MixedModelBootstrap{T<:AbstractFloat} <: MixedModelFitCollection{T}\n\nObject returned by parametericbootstrap with fields\n\nfits: the parameter estimates from the bootstrap replicates as a vector of named tuples.\nλ: Vector{LowerTriangular{T,Matrix{T}}} containing copies of the λ field from ReMat model terms\ninds: Vector{Vector{Int}} containing copies of the inds field from ReMat model terms\nlowerbd: Vector{T} containing the vector of lower bounds (corresponds to the lowerbd(model) of the original model)\nfcnames: NamedTuple whose keys are the grouping factor names and whose values are the column names\n\nThe schema of fits is, by default,\n\nTables.Schema:\n :objective  T\n :σ          T\n :β          NamedTuple{β_names}{NTuple{p,T}}\n :se         StaticArrays.SArray{Tuple{p},T,1,p}\n :θ          StaticArrays.SArray{Tuple{k},T,1,k}\n\nwhere the sizes, p and k, of the β and θ elements are determined by the model.\n\nCharacteristics of the bootstrap replicates can be extracted as properties.  The σs and σρs properties unravel the σ and θ estimates into estimates of the standard deviations and correlations of the random-effects terms.\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedModels.MixedModelFitCollection","page":"API","title":"MixedModels.MixedModelFitCollection","text":"MixedModelFitCollection{T<:AbstractFloat}\n\nAbstract supertype for MixedModelBootstrap and related functionality in other packages.\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedModels.MixedModelProfile","page":"API","title":"MixedModels.MixedModelProfile","text":" MixedModelProfile{T<:AbstractFloat}\n\nType representing a likelihood profile of a LinearMixedModel, including associated interpolation splines.\n\nThe function profile is used for computing profiles, while confint provides a useful method for constructing confidence intervals from a MixedModelProfile.\n\nnote: Note\nThe exact fields and their representation are considered implementation details and are not part of the public API.\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedModels.OptSummary","page":"API","title":"MixedModels.OptSummary","text":"OptSummary\n\nSummary of an optimization\n\nFields\n\nTolerances, initial and final values\n\ninitial: a copy of the initial parameter values in the optimization\nfinitial: the initial value of the objective\nfinal: a copy of the final parameter values from the optimization\nfmin: the final value of the objective\nfeval: the number of function evaluations  Available backends can be examined via OPTIMIZATION_BACKENDS.\nreturnvalue: the return value, as a Symbol. The available return values will differ between backends.\nxtol_zero_abs: the tolerance for a near zero parameter to be considered practically zero\nftol_zero_abs: the tolerance for change in the objective for setting a near zero parameter to zero\nmaxfeval: as in NLopt (maxeval) and PRIMA (maxfun)\n\nChoice of optimizer and backend\n\noptimizer: the name of the optimizer used, as a Symbol\nbackend: the optimization library providing the optimizer, stored as a symbol.  The current default is :nlopt.\n\nThe current default backend is NLopt, which is a direct dependency of MixedModels.jl. A PRIMA backend is also provided as a package extension and thus only available when the library PRIMA is loaded. The list of currently loaded backends is available as MixedModels.OPTIMIZATION_BACKENDS. For each individual backend, the list of available optimizers can be inspected with the function MixedModels.optimizers. Similarly, the list of applicable optimization parameters can be inspected with the function MixedModels.opt_params.\n\nnote: Optimizer defaults subject to change\nThe choice of backend and optimizer is subject to change without being considered a breaking change. If you want to guarantee a particular backend and optimizer, then you should explicitly load the associated backend's package (e.g. NLopt or PRIMA) and manually set the optimizer and backend fields.\n\nBackend-specific fields\n\nftol_rel: as in NLopt, not used in PRIMA\nftol_abs: as in NLopt, not used in PRIMA\nxtol_rel: as in NLopt, not used in PRIMA\nxtol_abs: as in NLopt, not used in PRIMA\ninitial_step: as in NLopt, not used in PRIMA\nmaxtime: as in NLopt, not used in PRIMA\nrhobeg: as in PRIMA, not used in NLopt\nrhoend: as in PRIMA, not used in NLopt\n\nMixedModels-specific fields, unrelated to the optimizer\n\nfitlog: A Tables.jl-compatible table with columns θ and objective. The precise type is an implementation detail\nnAGQ: number of adaptive Gauss-Hermite quadrature points in deviance evaluation for GLMMs\nREML: use the REML criterion for LMM fits\nsigma: a priori value for the residual standard deviation for LMM\n\nnote: Note\nThe internal storage of the parameter values within fitlog may change in the future to use a different subtype of AbstractVector (e.g., StaticArrays.SVector) for each snapshot without being considered a breaking change.\n\nnote: Note\nThe exact order and number of fields may change as support for additional backends and features thereof are added. In other words: use the keyword constructor and do not use the positional constructor.\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedModels.PCA","page":"API","title":"MixedModels.PCA","text":"PCA{T<:AbstractFloat}\n\nPrincipal Components Analysis\n\nFields\n\ncovcorr covariance or correlation matrix\nsv singular value decomposition\nrnames rownames of the original matrix\ncorr is this a correlation matrix?\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedModels.RaggedArray","page":"API","title":"MixedModels.RaggedArray","text":"RaggedArray{T,I}\n\nA \"ragged\" array structure consisting of values and indices\n\nFields\n\nvals: a Vector{T} containing the values\ninds: a Vector{I} containing the indices\n\nFor this application a RaggedArray is used only in its sum! method.\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedModels.ReMat","page":"API","title":"MixedModels.ReMat","text":"ReMat{T,S} <: AbstractMatrix{T}\n\nA section of a model matrix generated by a random-effects term.\n\nFields\n\ntrm: the grouping factor as a StatsModels.CategoricalTerm\nrefs: indices into the levels of the grouping factor as a Vector{Int32}\nlevels: the levels of the grouping factor\ncnames: the names of the columns of the model matrix generated by the left-hand side of the term\nz: transpose of the model matrix generated by the left-hand side of the term\nwtz: a weighted copy of z (z and wtz are the same object for unweighted cases)\nλ: a LowerTriangular or Diagonal matrix of size S×S\ninds: a Vector{Int} of linear indices of the potential nonzeros in λ\nadjA: the adjoint of the matrix as a SparseMatrixCSC{T}\nscratch: a Matrix{T}\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedModels.TableColumns","page":"API","title":"MixedModels.TableColumns","text":"TableColumns\n\nA structure containing the column names for the numeric part of the profile table.\n\nThe struct also contains a Dict giving the column ranges for Symbols like :σ and :β. Finally it contains a scratch vector used to accumulate to values in a row of the profile table.\n\nnote: Note\nThis is an internal structure used in MixedModelProfile. As such, it may change or disappear in a future release without being considered breaking.\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedModels.UniformBlockDiagonal","page":"API","title":"MixedModels.UniformBlockDiagonal","text":"UniformBlockDiagonal{T}\n\nHomogeneous block diagonal matrices.  k diagonal blocks each of size m×m\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedModels.VarCorr","page":"API","title":"MixedModels.VarCorr","text":"VarCorr\n\nInformation from the fitted random-effects variance-covariance matrices.\n\nMembers\n\nσρ: a NamedTuple of NamedTuples as returned from σρs\ns: the estimate of the per-observation dispersion parameter\n\nThe main purpose of defining this type is to isolate the logic in the show method.\n\n\n\n\n\n","category":"type"},{"location":"api/#LinearAlgebra.cond-Tuple{MixedModel}","page":"API","title":"LinearAlgebra.cond","text":"cond(m::MixedModel)\n\nReturn a vector of condition numbers of the λ matrices for the random-effects terms\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.logdet-Union{Tuple{LinearMixedModel{T}}, Tuple{T}} where T","page":"API","title":"LinearAlgebra.logdet","text":"logdet(m::LinearMixedModel)\n\nReturn the value of log(det(Λ'Z'ZΛ + I)) + m.optsum.REML * log(det(LX*LX')) evaluated in place.\n\nHere LX is the diagonal term corresponding to the fixed-effects in the blocked lower Cholesky factor.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.GHnorm-Tuple{Int64}","page":"API","title":"MixedModels.GHnorm","text":"GHnorm(k::Int)\n\nReturn the (unique) GaussHermiteNormalized{k} object.\n\nThe function values are stored (memoized) when first evaluated.  Subsequent evaluations for the same k have very low overhead.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.coefpvalues-Union{Tuple{MixedModels.MixedModelFitCollection{T}}, Tuple{T}} where T","page":"API","title":"MixedModels.coefpvalues","text":"coefpvalues(bsamp::MixedModelFitCollection)\n\nReturn a rowtable with columns (:iter, :coefname, :β, :se, :z, :p)\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.condVar-Union{Tuple{LinearMixedModel{T}}, Tuple{T}} where T","page":"API","title":"MixedModels.condVar","text":"condVar(m::LinearMixedModel)\n\nReturn the conditional variances matrices of the random effects.\n\nThe random effects are returned by ranef as a vector of length k, where k is the number of random effects terms.  The ith element is a matrix of size vᵢ × ℓᵢ  where vᵢ is the size of the vector-valued random effects for each of the ℓᵢ levels of the grouping factor.  Technically those values are the modes of the conditional distribution of the random effects given the observed data.\n\nThis function returns an array of k three dimensional arrays, where the ith array is of size vᵢ × vᵢ × ℓᵢ.  These are the diagonal blocks from the conditional variance-covariance matrix,\n\ns² Λ(Λ'Z'ZΛ + I)⁻¹Λ'\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.condVartables-Union{Tuple{MixedModel{T}}, Tuple{T}} where T","page":"API","title":"MixedModels.condVartables","text":"condVartables(m::LinearMixedModel)\n\nReturn the conditional covariance matrices of the random effects as a NamedTuple of columntables\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.fitted!-Union{Tuple{T}, Tuple{AbstractArray{T}, LinearMixedModel{T}}} where T","page":"API","title":"MixedModels.fitted!","text":"fitted!(v::AbstractArray{T}, m::LinearMixedModel{T})\n\nOverwrite v with the fitted values from m.\n\nSee also fitted.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.fixef-Union{Tuple{LinearMixedModel{T}}, Tuple{T}} where T","page":"API","title":"MixedModels.fixef","text":"fixef(m::MixedModel)\n\nReturn the fixed-effects parameter vector estimate of m.\n\nIn the rank-deficient case the truncated parameter vector, of length rank(m) is returned. This is unlike coef which always returns a vector whose length matches the number of columns in X.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.fixefnames-Tuple{LinearMixedModel}","page":"API","title":"MixedModels.fixefnames","text":"fixefnames(m::MixedModel)\n\nReturn a (permuted and truncated in the rank-deficient case) vector of coefficient names.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.fnames-Tuple{MixedModel}","page":"API","title":"MixedModels.fnames","text":"fnames(m::MixedModel)\n\nReturn the names of the grouping factors for the random-effects terms.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.glmm-Tuple","page":"API","title":"MixedModels.glmm","text":"glmm(args...; kwargs...)\n\nConvenience wrapper for fit(GeneralizedLinearMixedModel, args...; kwargs...).\n\nSee GeneralizedLinearMixedModel and fit! for more information.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.issingular-Tuple{MixedModels.MixedModelFitCollection}","page":"API","title":"MixedModels.issingular","text":"issingular(bsamp::MixedModelFitCollection;\n           atol::Real=0, rtol::Real=atol>0 ? 0 : √eps))\n\nTest each bootstrap sample for singularity of the corresponding fit.\n\nEquality comparisons are used b/c small non-negative θ values are replaced by 0 in fit!.\n\nSee also issingular(::MixedModel).\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.issingular-Union{Tuple{MixedModel{T}}, Tuple{T}, Tuple{MixedModel{T}, Any}} where T","page":"API","title":"MixedModels.issingular","text":"issingular(m::MixedModel, θ=m.θ; atol::Real=0, rtol::Real=atol>0 ? 0 : √eps)\n\nTest whether the model m is singular if the parameter vector is θ.\n\nEquality comparisons are used b/c small non-negative θ values are replaced by 0 in fit!.\n\nnote: Note\nFor GeneralizedLinearMixedModel, the entire parameter vector (including β in the case fast=false) must be specified if the default is not used.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.lmm-Tuple","page":"API","title":"MixedModels.lmm","text":"lmm(args...; kwargs...)\n\nConvenience wrapper for fit(LinearMixedModel, args...; kwargs...).\n\nSee LinearMixedModel and fit! for more information.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.lowerbd-Tuple{GeneralizedLinearMixedModel}","page":"API","title":"MixedModels.lowerbd","text":"lowerbd(m::GeneralizedLinearMixedModel)\n\nReturn the vector of canonical lower bounds on the parameters, θ.\n\nNote that this method does not distinguish between constrained optimization and unconstrained optimization with post-fit canonicalization.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.lowerbd-Union{Tuple{LinearMixedModel{T}}, Tuple{T}} where T","page":"API","title":"MixedModels.lowerbd","text":"lowerbd(m::LinearMixedModel)\n\nReturn the vector of canonical lower bounds on the parameters, θ.\n\nNote that this method does not distinguish between constrained optimization and unconstrained optimization with post-fit canonicalization.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.lowerbd-Union{Tuple{ReMat{T}}, Tuple{T}} where T","page":"API","title":"MixedModels.lowerbd","text":"lowerbd{T}(A::ReMat{T})\n\nReturn the vector of lower bounds on the parameters, θ associated with A.  For unconstrained optimization these are all T(-Inf)\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.objective!","page":"API","title":"MixedModels.objective!","text":"objective!(m::MixedModel, θ)\nobjective!(m::MixedModel)\n\nEquivalent to objective(updateL!(setθ!(m, θ))).\n\nWhen m has a single, scalar random-effects term, θ can be a scalar.\n\nThe one-argument method curries and returns a single-argument function of θ.\n\nNote that these methods modify m. The calling function is responsible for restoring the optimal θ.\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedModels.objective-Union{Tuple{LinearMixedModel{T}}, Tuple{T}} where T","page":"API","title":"MixedModels.objective","text":"objective(m::LinearMixedModel)\n\nReturn negative twice the log-likelihood of model m\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.parametricbootstrap-Union{Tuple{T}, Tuple{Random.AbstractRNG, Integer, MixedModel{T}}, Tuple{Random.AbstractRNG, Integer, MixedModel{T}, Type{<:AbstractFloat}}} where T","page":"API","title":"MixedModels.parametricbootstrap","text":"parametricbootstrap([rng::AbstractRNG], nsamp::Integer, m::MixedModel{T}, ftype=T;\n    β = fixef(m), σ = m.σ, θ = m.θ, progress=true, optsum_overrides=(;))\n\nPerform nsamp parametric bootstrap replication fits of m, returning a MixedModelBootstrap.\n\nThe default random number generator is Random.GLOBAL_RNG.\n\nftype can be used to store the computed bootstrap values in a lower precision. ftype is not a named argument because named arguments are not used in method dispatch and thus specialization. In other words, having ftype as a positional argument has some potential performance benefits.\n\nKeyword Arguments\n\nβ, σ, and θ are the values of m's parameters for simulating the responses.\nσ is only valid for LinearMixedModel and GeneralizedLinearMixedModel for\n\nfamilies with a dispersion parameter.\n\nprogress controls whether the progress bar is shown. Note that the progress\n\nbar is automatically disabled for non-interactive (i.e. logging) contexts.\n\noptsum_overrides is used to override values of OptSummary in the models\n\nfit during the bootstrapping process. For example, optsum_overrides=(;ftol_rel=1e-08) reduces the convergence criterion, which can greatly speed up the bootstrap fits. Taking advantage of this speed up to increase n can often lead to better estimates of coverage intervals.\n\nnote: Note\nAll coefficients are bootstrapped. In the rank deficient case, the inestimatable coefficients are treated as -0.0 in the simulations underlying the bootstrap, which will generally result in their estimate from the simulated data also being being inestimable and thus set to -0.0. However this behavior may change in future releases to explicitly drop the extraneous columns before simulation and thus not include their estimates in the bootstrap result.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.pirls!-Union{Tuple{GeneralizedLinearMixedModel{T}}, Tuple{T}, Tuple{GeneralizedLinearMixedModel{T}, Any}, Tuple{GeneralizedLinearMixedModel{T}, Any, Any}} where T","page":"API","title":"MixedModels.pirls!","text":"pirls!(m::GeneralizedLinearMixedModel)\n\nUse Penalized Iteratively Reweighted Least Squares (PIRLS) to determine the conditional modes of the random effects.\n\nWhen varyβ is true both u and β are optimized with PIRLS.  Otherwise only u is optimized and β is held fixed.\n\nPassing verbose = true provides verbose output of the iterations.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.profile-Tuple{LinearMixedModel}","page":"API","title":"MixedModels.profile","text":"profile(m::LinearMixedModel; threshold = 4)\n\nReturn a MixedModelProfile for the objective of m with respect to the fixed-effects coefficients.\n\nm is refit! if !isfitted(m).\n\nProfiling starts at the parameter estimate and continues until reaching a parameter bound or the absolute value of ζ exceeds threshold.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.profilevc-Union{Tuple{T}, Tuple{LinearMixedModel{T}, T, AbstractVector{T}}} where T","page":"API","title":"MixedModels.profilevc","text":" profilevc(m::LinearMixedModel{T}, val::T, rowj::AbstractVector{T}) where {T}\n\nProfile an element of the variance components.\n\nnote: Note\nThis method is called by profile and currently considered internal. As such, it may change or disappear in a future release without being considered breaking.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.profileσ-Union{Tuple{T}, Tuple{LinearMixedModel{T}, MixedModels.TableColumns{T}}} where T","page":"API","title":"MixedModels.profileσ","text":"profileσ(m::LinearMixedModel, tc::TableColumns; threshold=4)\n\nReturn a Table of the profile of σ for model m.  The profile extends to where the magnitude of ζ exceeds threshold.\n\nnote: Note\nThis method is called by profile and currently considered internal. As such, it may change or disappear in a future release without being considered breaking.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.pwrss-Union{Tuple{LinearMixedModel{T}}, Tuple{T}} where T","page":"API","title":"MixedModels.pwrss","text":"pwrss(m::LinearMixedModel)\n\nThe penalized, weighted residual sum-of-squares.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.ranef-Union{Tuple{LinearMixedModel{T}}, Tuple{T}} where T","page":"API","title":"MixedModels.ranef","text":"ranef(m::LinearMixedModel; uscale=false)\n\nReturn, as a Vector{Matrix{T}}, the conditional modes of the random effects in model m.\n\nIf uscale is true the random effects are on the spherical (i.e. u) scale, otherwise on the original scale.\n\nFor a named variant, see raneftables.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.raneftables-Union{Tuple{MixedModel{T}}, Tuple{T}} where T","page":"API","title":"MixedModels.raneftables","text":"raneftables(m::MixedModel; uscale = false)\n\nReturn the conditional means of the random effects as a NamedTuple of Tables.jl-compliant tables.\n\nnote: Note\nThe API guarantee is only that the NamedTuple contains Tables.jl tables and not on the particular concrete type of each table.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.refit!-Tuple{GeneralizedLinearMixedModel}","page":"API","title":"MixedModels.refit!","text":"refit!(m::GeneralizedLinearMixedModel[, y::Vector];\n       fast::Bool = (length(m.θ) == length(m.optsum.final)),\n       nAGQ::Integer = m.optsum.nAGQ,\n       kwargs...)\n\nRefit the model m after installing response y.\n\nIf y is omitted the current response vector is used.\n\nIf not specified, the fast and nAGQ options from the previous fit are used. kwargs are the same as fit!\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.refit!-Tuple{LinearMixedModel}","page":"API","title":"MixedModels.refit!","text":"refit!(m::LinearMixedModel[, y::Vector]; REML=m.optsum.REML, kwargs...)\n\nRefit the model m after installing response y.\n\nIf y is omitted the current response vector is used. kwargs are the same as fit!.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.replicate-Tuple{Function, Integer}","page":"API","title":"MixedModels.replicate","text":"replicate(f::Function, n::Integer; progress=true)\n\nReturn a vector of the values of n calls to f() - used in simulations where the value of f is stochastic.\n\nprogress controls whether the progress bar is shown. Note that the progress bar is automatically disabled for non-interactive (i.e. logging) contexts.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.restoreoptsum!-Tuple{MixedModel, Any}","page":"API","title":"MixedModels.restoreoptsum!","text":"restoreoptsum!(m::MixedModel, io::IO; atol::Real=0, rtol::Real=atol>0 ? 0 : √eps)\nrestoreoptsum!(m::MixedModel, filename; atol::Real=0, rtol::Real=atol>0 ? 0 : √eps)\n\nRead, check, and restore the optsum field from a JSON stream or filename.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.restorereplicates-Union{Tuple{T}, Tuple{Any, MixedModel{T}}, Tuple{Any, MixedModel{T}, Type{<:AbstractFloat}}} where T","page":"API","title":"MixedModels.restorereplicates","text":"restorereplicates(f, m::MixedModel{T})\nrestorereplicates(f, m::MixedModel{T}, ftype::Type{<:AbstractFloat})\nrestorereplicates(f, m::MixedModel{T}, ctype::Type{<:MixedModelFitCollection{S}})\n\nRestore replicates from f, using m to create the desired subtype of MixedModelFitCollection.\n\nf can be any entity supported by Arrow.Table. m does not have to be fitted, but it must have been constructed with the same structure as the source of the saved replicates.\n\nThe two-argument method constructs a MixedModelBootstrap with the same eltype as m. If an eltype is specified as the third argument, then a MixedModelBootstrap is returned. If a subtype of MixedModelFitCollection is specified as the third argument, then that is the return type.\n\nSee also savereplicates, restoreoptsum!.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.saveoptsum-Tuple{IO, MixedModel}","page":"API","title":"MixedModels.saveoptsum","text":"saveoptsum(io::IO, m::MixedModel)\nsaveoptsum(filename, m::MixedModel)\n\nSave m.optsum in JSON format to an IO stream or a file\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.savereplicates-Tuple{Any, MixedModels.MixedModelFitCollection}","page":"API","title":"MixedModels.savereplicates","text":"savereplicates(f, b::MixedModelFitCollection)\n\nSave the replicates associated with a MixedModelFitCollection, e.g. MixedModelBootstrap as an Arrow file.\n\nSee also restorereplicates, saveoptsum\n\nnote: Note\nOnly the replicates are saved, not the entire contents of the MixedModelFitCollection. restorereplicates requires a model compatible with the bootstrap to restore the full object.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.sdest-Tuple{LinearMixedModel}","page":"API","title":"MixedModels.sdest","text":"sdest(m::LinearMixedModel)\n\nReturn the estimate of σ, the standard deviation of the per-observation noise.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.sdest-Union{Tuple{GeneralizedLinearMixedModel{T}}, Tuple{T}} where T","page":"API","title":"MixedModels.sdest","text":"sdest(m::GeneralizedLinearMixedModel)\n\nReturn the estimate of the dispersion, i.e. the standard deviation of the per-observation noise.\n\nFor models with a dispersion parameter ϕ, this is simply ϕ. For models without a dispersion parameter, this value is missing. This differs from disperion, which returns 1 for models without a dispersion parameter.\n\nFor Gaussian models, this parameter is often called σ.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.setθ!-Union{Tuple{T}, Tuple{LinearMixedModel{T}, AbstractVector}} where T","page":"API","title":"MixedModels.setθ!","text":"setθ!(m::LinearMixedModel, v)\n\nInstall v as the θ parameters in m.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.setθ!-Union{Tuple{T}, Tuple{MixedModels.MixedModelFitCollection{T}, AbstractVector{T}}} where T","page":"API","title":"MixedModels.setθ!","text":"setθ!(bsamp::MixedModelFitCollection, θ::AbstractVector)\nsetθ!(bsamp::MixedModelFitCollection, i::Integer)\n\nInstall the values of the i'th θ value of bsamp.fits in bsamp.λ\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.shortestcovint","page":"API","title":"MixedModels.shortestcovint","text":"shortestcovint(v, level = 0.95)\n\nReturn the shortest interval containing level proportion of the values of v\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedModels.shortestcovint-Union{Tuple{MixedModels.MixedModelFitCollection{T}}, Tuple{T}, Tuple{MixedModels.MixedModelFitCollection{T}, Any}} where T","page":"API","title":"MixedModels.shortestcovint","text":"shortestcovint(bsamp::MixedModelFitCollection, level = 0.95)\n\nReturn the shortest interval containing level proportion for each parameter from bsamp.allpars.\n\nwarning: Warning\nCurrently, correlations that are systematically zero are included in the the result. This may change in a future release without being considered a breaking change.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.simulate","page":"API","title":"MixedModels.simulate","text":"See simulate!\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedModels.simulate!-Tuple{Random.AbstractRNG, AbstractVector, LinearMixedModel, NamedTuple{names, T} where {N, names, T<:Tuple{Vararg{AbstractVector, N}}}}","page":"API","title":"MixedModels.simulate!","text":"simulate!([rng::AbstractRNG,] y::AbstractVector, m::MixedModel{T}[, newdata];\n                β = coef(m), σ = m.σ, θ = T[], wts=m.wts)\nsimulate([rng::AbstractRNG,] m::MixedModel{T}[, newdata];\n                β = coef(m), σ = m.σ, θ = T[], wts=m.wts)\n\nSimulate a new response vector, optionally overwriting a pre-allocated vector.\n\nNew data can be optionally provided in tabular format.\n\nThis simulation includes sampling new values for the random effects. Thus in contrast to predict, there is no distinction in between \"new\" and \"old\" / previously observed random-effects levels.\n\nUnlike predict, there is no type parameter for GeneralizedLinearMixedModel because the noise term in the model and simulation is always on the response scale.\n\nThe wts argument is currently ignored except for GeneralizedLinearMixedModel models with a Binomial distribution.\n\nnote: Note\nNote that simulate! methods with a y::AbstractVector as the first argument (besides the RNG) and simulate methods return the simulated response. This is in contrast to simulate! methods with a m::MixedModel as the first argument, which modify the model's response and return the entire modified model.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.simulate!-Union{Tuple{T}, Tuple{Random.AbstractRNG, LinearMixedModel{T}}} where T","page":"API","title":"MixedModels.simulate!","text":"simulate!(rng::AbstractRNG, m::MixedModel{T}; β=fixef(m), σ=m.σ, θ=T[])\nsimulate!(m::MixedModel; β=fixef(m), σ=m.σ, θ=m.θ)\n\nOverwrite the response (i.e. m.trms[end]) with a simulated response vector from model m.\n\nThis simulation includes sampling new values for the random effects.\n\nβ can be specified either as a pivoted, full rank coefficient vector (cf. fixef) or as an unpivoted full dimension coefficient vector (cf. coef), where the entries corresponding to redundant columns will be ignored.\n\nnote: Note\nNote that simulate! methods with a y::AbstractVector as the first argument (besides the RNG) and simulate methods return the simulated response. This is in contrast to simulate! methods with a m::MixedModel as the first argument, which modify the model's response and return the entire modified model.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.sparseL-Union{Tuple{LinearMixedModel{T}}, Tuple{T}} where T","page":"API","title":"MixedModels.sparseL","text":"sparseL(m::LinearMixedModel; fname::Symbol=first(fnames(m)), full::Bool=false)\n\nReturn the lower Cholesky factor L as a SparseMatrix{T,Int32}.\n\nfull indicates whether the parts of L associated with the fixed-effects and response are to be included.\n\nfname specifies the first grouping factor to include. Blocks to the left of the block corresponding  to fname are dropped. The default is the first, i.e., leftmost block and hence all blocks.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.stderror!-Union{Tuple{T}, Tuple{Tv}, Tuple{AbstractVector{Tv}, LinearMixedModel{T}}} where {Tv, T}","page":"API","title":"MixedModels.stderror!","text":"stderror!(v::AbstractVector, m::LinearMixedModel)\n\nOverwrite v with the standard errors of the fixed-effects coefficients in m\n\nThe length of v should be the total number of coefficients (i.e. length(coef(m))). When the model matrix is rank-deficient the coefficients forced to -0.0 have an undefined (i.e. NaN) standard error.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.updateL!-Union{Tuple{LinearMixedModel{T}}, Tuple{T}} where T","page":"API","title":"MixedModels.updateL!","text":"updateL!(m::LinearMixedModel)\n\nUpdate the blocked lower Cholesky factor, m.L, from m.A and m.reterms (used for λ only)\n\nThis is the crucial step in evaluating the objective, given a new parameter value.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.varest-Tuple{LinearMixedModel}","page":"API","title":"MixedModels.varest","text":"varest(m::LinearMixedModel)\n\nReturns the estimate of σ², the variance of the conditional distribution of Y given B.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.varest-Union{Tuple{GeneralizedLinearMixedModel{T}}, Tuple{T}} where T","page":"API","title":"MixedModels.varest","text":"varest(m::GeneralizedLinearMixedModel)\n\nReturns the estimate of ϕ², the variance of the conditional distribution of Y given B.\n\nFor models with a dispersion parameter ϕ, this is simply ϕ². For models without a dispersion parameter, this value is missing. This differs from disperion, which returns 1 for models without a dispersion parameter.\n\nFor Gaussian models, this parameter is often called σ².\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.zerocorr-Tuple{Any}","page":"API","title":"MixedModels.zerocorr","text":"zerocorr(term::RandomEffectsTerm)\n\nRemove correlations between random effects in term.\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.std-Tuple{LinearMixedModel}","page":"API","title":"Statistics.std","text":"std(m::MixedModel)\n\nReturn the estimated standard deviations of the random effects as a Vector{Vector{T}}.\n\nFIXME: This uses an old convention of isfinite(sdest(m)).  Probably drop in favor of m.σs\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.confint-Tuple{MixedModelProfile}","page":"API","title":"StatsAPI.confint","text":"confint(pr::MixedModelProfile; level::Real=0.95)\n\nCompute profile confidence intervals for coefficients and variance components, with confidence level level (by default 95%).\n\nnote: Note\nThe API guarantee is for a Tables.jl compatible table. The exact return type is an implementation detail and may change in a future minor release without being considered breaking.\n\nnote: Note\nThe \"row names\" indicating the associated parameter name are guaranteed to be unambiguous, but their precise naming scheme is not yet stable and may change in a future release without being considered breaking.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.confint-Union{Tuple{MixedModelBootstrap{T}}, Tuple{T}} where T","page":"API","title":"StatsAPI.confint","text":"confint(pr::MixedModelBootstrap; level::Real=0.95, method=:shortest)\n\nCompute bootstrap confidence intervals for coefficients and variance components, with confidence level level (by default 95%).\n\nThe keyword argument method determines whether the :shortest, i.e. highest density, interval is used or the :equaltail, i.e. quantile-based, interval is used. For historical reasons, the default is :shortest, but :equaltail gives the interval that is most comparable to the profile and Wald confidence intervals.\n\nnote: Note\nThe API guarantee is for a Tables.jl compatible table. The exact return type is an implementation detail and may change in a future minor release without being considered breaking.\n\nnote: Note\nThe \"row names\" indicating the associated parameter name are guaranteed to be unambiguous, but their precise naming scheme is not yet stable and may change in a future release without being considered breaking.\n\nSee also shortestcovint.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.confint-Union{Tuple{MixedModel{T}}, Tuple{T}} where T","page":"API","title":"StatsAPI.confint","text":"confint(pr::MixedModelProfile; level::Real=0.95)\n\nCompute profile confidence intervals for (fixed effects) coefficients, with confidence level level (by default 95%).\n\nnote: Note\nThe API guarantee is for a Tables.jl compatible table. The exact return type is an implementation detail and may change in a future minor release without being considered breaking.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.deviance-Union{Tuple{GeneralizedLinearMixedModel{T}}, Tuple{T}, Tuple{GeneralizedLinearMixedModel{T}, Any}} where T","page":"API","title":"StatsAPI.deviance","text":"deviance(m::GeneralizedLinearMixedModel{T}, nAGQ=1)::T where {T}\n\nReturn the deviance of m evaluated by the Laplace approximation (nAGQ=1) or nAGQ-point adaptive Gauss-Hermite quadrature.\n\nIf the distribution D does not have a scale parameter the Laplace approximation is the squared length of the conditional modes, u, plus the determinant of ΛZWZΛ + I, plus the sum of the squared deviance residuals.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.dof_residual-Tuple{MixedModel}","page":"API","title":"StatsAPI.dof_residual","text":"dof_residual(m::MixedModel)\n\nReturn the residual degrees of freedom of the model.\n\nnote: Note\nThe residual degrees of freedom for mixed-effects models is not clearly defined due to partial pooling. The classical nobs(m) - dof(m) fails to capture the extra freedom granted by the random effects, but nobs(m) - nranef(m) would overestimate the freedom granted by the random effects. nobs(m) - sum(leverage(m)) provides a nice balance based on the relative influence of each observation, but is computationally expensive for large models. This problem is also fundamentally related to long-standing debates about the appropriate treatment of the denominator degrees of freedom for F-tests. In the future, MixedModels.jl may provide additional methods allowing the user to choose the computation to use.\n\nwarning: Warning\nCurrently, the residual degrees of freedom is computed as nobs(m) - dof(m), but this may change in the future without being considered a breaking change because there is no canonical definition of the residual degrees of freedom in a mixed-effects model.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.fit!-Union{Tuple{GeneralizedLinearMixedModel{T}}, Tuple{T}} where T","page":"API","title":"StatsAPI.fit!","text":"fit!(m::GeneralizedLinearMixedModel; fast=false, nAGQ=1,\n                                     verbose=false, progress=true,\n                                     init_from_lmm=Set())\n\nOptimize the objective function for m.\n\nWhen fast is true a potentially much faster but slightly less accurate algorithm, in which pirls! optimizes both the random effects and the fixed-effects parameters, is used.\n\nIf progress is true, the default, a ProgressMeter.ProgressUnknown counter is displayed. during the iterations to minimize the deviance.  There is a delay before this display is initialized and it may not be shown at all for models that are optimized quickly.\n\nIf verbose is true, then both the intermediate results of both the nonlinear optimization and PIRLS are also displayed on standard output.\n\nBy default, the starting values for model fitting are taken from a (non mixed, i.e. marginal ) GLM fit. Experience with larger datasets (many thousands of observations and/or hundreds of levels of the grouping variables) has suggested that fitting a (Gaussian) linear mixed model on the untransformed data may provide better starting values and thus overall faster fits even though an entire LMM must be fit before the GLMM can be fit. init_from_lmm can be used to specify which starting values from an LMM to use. Valid options are any collection (array, set, etc.) containing one or more of :β and :θ, the default is the empty set.\n\nnote: Note\nInitializing from an LMM requires fitting the entire LMM first, so when progress=true, there will be two progress bars: first for the LMM, then for the GLMM.\n\nwarning: Warning\nThe init_from_lmm functionality is experimental and may change or be removed entirely without being considered a breaking change.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.fit!-Union{Tuple{LinearMixedModel{T}}, Tuple{T}} where T","page":"API","title":"StatsAPI.fit!","text":"fit!(m::LinearMixedModel; progress::Bool=true, REML::Bool=m.optsum.REML,\n                          σ::Union{Real, Nothing}=m.optsum.sigma)\n\nOptimize the objective of a LinearMixedModel.  When progress is true a ProgressMeter.ProgressUnknown display is shown during the optimization of the objective, if the optimization takes more than one second or so.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.leverage-Union{Tuple{LinearMixedModel{T}}, Tuple{T}} where T","page":"API","title":"StatsAPI.leverage","text":"leverage(::LinearMixedModel)\n\nReturn the diagonal of the hat matrix of the model.\n\nFor a linear model, the sum of the leverage values is the degrees of freedom for the model in the sense that this sum is the dimension of the span of columns of the model matrix.  With a bit of hand waving a similar argument could be made for linear mixed-effects models. The hat matrix is of the form ZΛ XL L¹ZΛ X.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.modelmatrix-Tuple{MixedModel}","page":"API","title":"StatsAPI.modelmatrix","text":"modelmatrix(m::MixedModel)\n\nReturns the model matrix X for the fixed-effects parameters, as returned by coef.\n\nThis is always the full model matrix in the original column order and from a field in the model struct.  It should be copied if it is to be modified.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.predict-Tuple{LinearMixedModel, NamedTuple{names, T} where {N, names, T<:Tuple{Vararg{AbstractVector, N}}}}","page":"API","title":"StatsAPI.predict","text":"StatsAPI.predict(m::LinearMixedModel, newdata;\n                new_re_levels=:missing)\nStatsAPI.predict(m::GeneralizedLinearMixedModel, newdata;\n                new_re_levels=:missing, type=:response)\n\nPredict response for new data.\n\nnote: Note\nCurrently, no in-place methods are provided because these methods internally construct a new model and therefore allocate not just a response vector but also many other matrices.\n\nwarning: Warning\nnewdata should contain a column for the response (dependent variable) initialized to some numerical value (not missing), because this is used to construct the new model used in computing the predictions. missing is not valid because missing data are dropped before constructing the model matrices.\n\nwarning: Warning\nThese methods construct an entire MixedModel behind the scenes and as such may use a large amount of memory when newdata is large.\n\nwarning: Warning\nRank-deficiency can lead to surprising but consistent behavior. For example, if there are two perfectly collinear predictors A and B (e.g. constant multiples of each other), then it is possible that A will be pivoted out in the fitted model and thus the associated coefficient is set to zero. If predictions are then generated on new data where B has been set to zero but A has not, then there will no contribution from neither A nor B in the resulting predictions.\n\nThe keyword argument new_re_levels specifies how previously unobserved values of the grouping variable are handled. Possible values are:\n\n:population: return population values for the relevant grouping variable.  In other words, treat the associated random effect as 0.  If all grouping variables have new levels, then this is equivalent to  just the fixed effects.\n:missing: return missing.\n:error: error on this condition. The error type is an implementation detail:  you should not rely on a particular type of error being thrown.\n\nIf you want simulated values for unobserved levels of the grouping variable, consider the simulate! and simulate methods.\n\nPredictions based purely on the fixed effects can be obtained by specifying previously unobserved levels of the random effects and setting new_re_levels=:population. Similarly, the contribution of any grouping variable can be excluded by specifying previously unobserved levels, while including previously observed levels of the other grouping variables. In the future, it may be possible to specify a subset of the grouping variables or overall random-effects structure to use, but not at this time.\n\nnote: Note\nnew_re_levels impacts only the behavior for previously unobserved random effects levels, i.e. new RE levels. For previously observed random effects levels, predictions take both the fixed and random effects into account.\n\nFor GeneralizedLinearMixedModel, the type parameter specifies whether the predictions should be returned on the scale of linear predictor (:linpred) or on the response scale (:response). If you don't know the difference between these terms, then you probably want type=:response.\n\nRegression weights are not yet supported in prediction. Similarly, offsets are also not supported for GeneralizedLinearMixedModel.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.pvalue-Tuple{MixedModels.LikelihoodRatioTest}","page":"API","title":"StatsAPI.pvalue","text":"pvalue(lrt::LikelihoodRatioTest)\n\nExtract the p-value associated with a likelihood ratio test.\n\nFor LikelihoodRatioTests containing more than one model comparison, i.e. more than two models, this throws an error because it is unclear which p-value is desired.\n\nTo get p-values for multiple tests, use lrt.pvalues.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.response-Tuple{MixedModel}","page":"API","title":"StatsAPI.response","text":"response(m::MixedModel)\n\nReturn the response vector for the model.\n\nFor a linear mixed model this is a view of the last column of the XyMat field. For a generalized linear mixed model this is the m.resp.y field. In either case it should be copied if it is to be modified.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.vcov-Tuple{MixedModel}","page":"API","title":"StatsAPI.vcov","text":"vcov(m::MixedModel; corr=false)\n\nReturns the variance-covariance matrix of the fixed effects. If corr is true, the correlation of the fixed effects is returned instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tables.columntable-Tuple{OptSummary}","page":"API","title":"Tables.columntable","text":"columntable(s::OptSummary, [stack::Bool=false])\n\nReturn s.fitlog as a Tables.columntable.\n\nWhen stack is false (the default), there will be 3 columns in the result:\n\niter: the iteration number\nobjective: the value of the objective at that sample\nθ: the parameter vector at that sample\n\nWhen stack is true, there will be 4 columns: iter, objective, par, and value where value is the stacked contents of the θ vectors (the equivalent of vcat(θ...)) and par is a vector of parameter numbers.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.copy-Union{Tuple{ReMat{T, S}}, Tuple{S}, Tuple{T}} where {T, S}","page":"API","title":"Base.copy","text":"Base.copy(ReMat{T,S})\n\nReturn a shallow copy of ReMat.\n\nA shallow copy shares as much internal storage as possible with the original ReMat. Only the vector λ and the scratch matrix are copied.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.size-Tuple{MixedModel}","page":"API","title":"Base.size","text":"size(m::MixedModel)\n\nReturns the size of a mixed model as a tuple of length four: the number of observations, the number of (non-singular) fixed-effects parameters, the number of conditional modes (random effects), the number of grouping variables\n\n\n\n\n\n","category":"method"},{"location":"api/#GLM.wrkresp!-Union{Tuple{T}, Tuple{AbstractVector{T}, GLM.GlmResp{Vector{T}}}} where T<:AbstractFloat","page":"API","title":"GLM.wrkresp!","text":"GLM.wrkresp!(v::AbstractVector{T}, resp::GLM.GlmResp{AbstractVector{T}})\n\nA copy of a method from GLM that generalizes the types in the signature\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.LD-Union{Tuple{LinearAlgebra.Diagonal{T, V} where V<:AbstractVector{T}}, Tuple{T}} where T<:Number","page":"API","title":"MixedModels.LD","text":"LD(A::Diagonal)\nLD(A::HBlikDiag)\nLD(A::DenseMatrix)\n\nReturn log(det(tril(A))) evaluated in place.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.Omega_dot_diag_block!-Union{Tuple{T}, Tuple{LinearAlgebra.Diagonal{T, Vector{T}}, LinearMixedModel{T}, Integer}} where T","page":"API","title":"MixedModels.Omega_dot_diag_block!","text":"Omegadotdiag_block!(blk, m::LinearMixedModel, p::Integer)\n\nFill blk as the non-zero diagonal block of ∂Ω/∂θₚ for parameter number p of model m.\n\nFor any p only one diagonal block of ∂Ω/∂θₚ will be non-zero.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.adjA-Tuple{AbstractVector, AbstractMatrix}","page":"API","title":"MixedModels.adjA","text":"adjA(refs::AbstractVector, z::AbstractMatrix{T})\n\nReturns the adjoint of an ReMat as a SparseMatrixCSC{T,Int32}\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.allpars-Union{Tuple{MixedModels.MixedModelFitCollection{T}}, Tuple{T}} where T","page":"API","title":"MixedModels.allpars","text":"allpars(bsamp::MixedModelFitCollection)\n\nReturn a tidy (column)table with the parameter estimates spread into columns of iter, type, group, name and value.\n\nwarning: Warning\nCurrently, correlations that are systematically zero are included in the the result. This may change in a future release without being considered a breaking change.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.amalgamate-Union{Tuple{Vector{<:AbstractReMat{T}}}, Tuple{T}} where T","page":"API","title":"MixedModels.amalgamate","text":"amalgamate(reterms::Vector{AbstractReMat})\n\nCombine multiple ReMat with the same grouping variable into a single object.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.average-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractFloat","page":"API","title":"MixedModels.average","text":"average(a::T, b::T) where {T<:AbstractFloat}\n\nReturn the average of a and b\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.block-Tuple{Integer, Integer}","page":"API","title":"MixedModels.block","text":"block(i, j)\n\nReturn the linear index of the [i,j] position (\"block\") in the row-major packed lower triangle.\n\nUse the row-major ordering in this case because the result depends only on i and j, not on the overall size of the array.\n\nWhen i == j the value is the same as kp1choose2(i).\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.cholUnblocked!","page":"API","title":"MixedModels.cholUnblocked!","text":"cholUnblocked!(A, Val{:L})\n\nOverwrite the lower triangle of A with its lower Cholesky factor.\n\nThe name is borrowed from [https://github.com/andreasnoack/LinearAlgebra.jl] because these are part of the inner calculations in a blocked Cholesky factorization.\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedModels.copyscaleinflate!","page":"API","title":"MixedModels.copyscaleinflate!","text":"copyscaleinflate!(L::AbstractMatrix, A::AbstractMatrix, Λ::ReMat)\n\nOverwrite L with Λ'AΛ + I\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedModels.copyskip!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Integer, Integer, Integer}} where T","page":"API","title":"MixedModels.copyskip!","text":"copyskip!(B::Matrix{T}, A::Matrix{T}, i::Integer, j::Integer, k::Integer) where {T}\n\nCreate A * Ω_dot in B where Ω_dot is the indicator for the i'th row and j'th column in a matrix of size k\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.corrmat-Union{Tuple{ReMat{T}}, Tuple{T}} where T","page":"API","title":"MixedModels.corrmat","text":"corrmat(A::ReMat)\n\nReturn the estimated correlation matrix for A.  The diagonal elements are 1 and the off-diagonal elements are the correlations between those random effect terms\n\nExample\n\nNote that trailing digits may vary slightly depending on the local platform.\n\njulia> using MixedModels\n\njulia> mod = fit(MixedModel,\n                 @formula(rt_trunc ~ 1 + spkr + prec + load + (1 + spkr + prec | subj)),\n                 MixedModels.dataset(:kb07));\n\njulia> VarCorr(mod)\nVariance components:\n             Column      Variance  Std.Dev.  Corr.\nsubj     (Intercept)     136591.782 369.583\n         spkr: old        22922.871 151.403 +0.21\n         prec: maintain   32348.269 179.856 -0.98 -0.03\nResidual                 642324.531 801.452\n\njulia> MixedModels.corrmat(mod.reterms[1])\n3×3 LinearAlgebra.Symmetric{Float64,Array{Float64,2}}:\n  1.0        0.214816   -0.982948\n  0.214816   1.0        -0.0315607\n -0.982948  -0.0315607   1.0\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.cpad-Tuple{String, Integer}","page":"API","title":"MixedModels.cpad","text":"cpad(s::AbstractString, n::Integer)\n\nReturn a string of length n containing s in the center (more-or-less).\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.densify","page":"API","title":"MixedModels.densify","text":"densify(S::SparseMatrix, threshold=0.1)\n\nConvert sparse S to Diagonal if S is diagonal or to Array(S) if the proportion of nonzeros exceeds threshold.\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedModels.deviance!","page":"API","title":"MixedModels.deviance!","text":"deviance!(m::GeneralizedLinearMixedModel, nAGQ=1)\n\nUpdate m.η, m.μ, etc., install the working response and working weights in m.LMM, update m.LMM.A and m.LMM.R, then evaluate the deviance.\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedModels.eval_grad_p!-Union{Tuple{T}, Tuple{Array{AbstractMatrix{T}, 2}, LinearMixedModel{T}, Integer}} where T","page":"API","title":"MixedModels.eval_grad_p!","text":"eval_grad_p!(blks, m, p)\n\nEvaluate the gradient component for parameter p in model m using blocks in blks for storage\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.fd_cholUnblocked!","page":"API","title":"MixedModels.fd_cholUnblocked!","text":"fd_cholUnblocked!\n\nForwardDiff.jl compatible cholUnblocked!.\n\nwarning: ForwardDiff.jl support is experimental.\nCompatibility with ForwardDiff.jl is experimental. The precise structure, including function names and method definitions, is subject to change without being considered a breaking change. In particular, the whole set of fd_ functions should be considered private implementation details.\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedModels.fd_deviance","page":"API","title":"MixedModels.fd_deviance","text":"fd_deviance\n\nForwardDiff.jl compatible deviance.\n\nwarning: ForwardDiff.jl support is experimental.\nCompatibility with ForwardDiff.jl is experimental. The precise structure, including function names and method definitions, is subject to change without being considered a breaking change. In particular, the whole set of fd_ functions should be considered private implementation details.\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedModels.fd_logdet","page":"API","title":"MixedModels.fd_logdet","text":"fd_logdet\n\nForwardDiff.jl compatible logdet.\n\nwarning: ForwardDiff.jl support is experimental.\nCompatibility with ForwardDiff.jl is experimental. The precise structure, including function names and method definitions, is subject to change without being considered a breaking change. In particular, the whole set of fd_ functions should be considered private implementation details.\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedModels.fd_pwrss","page":"API","title":"MixedModels.fd_pwrss","text":"fd_pwrss\n\nForwardDiff.jl compatible pwrss.\n\nwarning: ForwardDiff.jl support is experimental.\nCompatibility with ForwardDiff.jl is experimental. The precise structure, including function names and method definitions, is subject to change without being considered a breaking change. In particular, the whole set of fd_ functions should be considered private implementation details.\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedModels.fd_rankUpdate!","page":"API","title":"MixedModels.fd_rankUpdate!","text":"fd_rankUpdate!\n\nForwardDiff.jl compatible rankUpdate!.\n\nwarning: ForwardDiff.jl support is experimental.\nCompatibility with ForwardDiff.jl is experimental. The precise structure, including function names and method definitions, is subject to change without being considered a breaking change. In particular, the whole set of fd_ functions should be considered private implementation details.\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedModels.fd_setθ!","page":"API","title":"MixedModels.fd_setθ!","text":"fd_setθ!\n\nForwardDiff.jl compatible setθ!.\n\nwarning: ForwardDiff.jl support is experimental.\nCompatibility with ForwardDiff.jl is experimental. The precise structure, including function names and method definitions, is subject to change without being considered a breaking change. In particular, the whole set of fd_ functions should be considered private implementation details.\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedModels.fd_updateL!","page":"API","title":"MixedModels.fd_updateL!","text":"fd_updateL!\n\nForwardDiff.jl compatible updateL!.\n\nwarning: ForwardDiff.jl support is experimental.\nCompatibility with ForwardDiff.jl is experimental. The precise structure, including function names and method definitions, is subject to change without being considered a breaking change. In particular, the whole set of fd_ functions should be considered private implementation details.\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedModels.feL-Tuple{LinearMixedModel}","page":"API","title":"MixedModels.feL","text":"feL(m::LinearMixedModel)\n\nReturn the lower Cholesky factor for the fixed-effects parameters, as an LowerTriangular p × p matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.fixef!-Union{Tuple{T}, Tuple{Tv}, Tuple{AbstractVector{Tv}, LinearMixedModel{T}}} where {Tv, T}","page":"API","title":"MixedModels.fixef!","text":"fixef!(v::Vector{T}, m::MixedModel{T})\n\nOverwrite v with the pivoted fixed-effects coefficients of model m\n\nFor full-rank models the length of v must be the rank of X.  For rank-deficient models the length of v can be the rank of X or the number of columns of X.  In the latter case the calculated coefficients are padded with -0.0 out to the number of columns.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.fname-Tuple{ReMat}","page":"API","title":"MixedModels.fname","text":"fname(A::ReMat)\n\nReturn the name of the grouping factor as a Symbol\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.getθ!-Union{Tuple{T}, Tuple{AbstractVector{T}, ReMat{T}}} where T","page":"API","title":"MixedModels.getθ!","text":"getθ!(v::AbstractVector{T}, A::ReMat{T}) where {T}\n\nOverwrite v with the elements of the blocks in the lower triangle of A.Λ (column-major ordering)\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.getθ-Union{Tuple{LinearMixedModel{T}}, Tuple{T}} where T","page":"API","title":"MixedModels.getθ","text":"getθ(m::LinearMixedModel)\n\nReturn the current covariance parameter vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.grad_blocks-Union{Tuple{LinearMixedModel{T}}, Tuple{T}} where T","page":"API","title":"MixedModels.grad_blocks","text":"grad_blocks(m::LinearMixedModel{T})\n\nReturn Matrix{AbstractMatrix{T}} containing the gradient-evaluation blocks for model m.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.indmat","page":"API","title":"MixedModels.indmat","text":"indmat(A::ReMat)\n\nReturn a Bool indicator matrix of the potential non-zeros in A.λ\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedModels.initialize_blocks!-Union{Tuple{T}, Tuple{Array{AbstractMatrix{T}, 2}, LinearMixedModel{T}, Integer}} where T","page":"API","title":"MixedModels.initialize_blocks!","text":"initialize_blocks!(blks::Matrix{AbstractMatrix{T}}, m::LinearMixedModel{T}, p::Integer)\n\nInitialize the grad evaluation blocks, blks, for model m, for parameter p\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.isconstant-Tuple{Any}","page":"API","title":"MixedModels.isconstant","text":"isconstant(x::Array)\nisconstant(x::Tuple)\n\nAre all elements of the iterator the same?  That is, is it constant?\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.isfullrank-Tuple{MixedModels.FeTerm}","page":"API","title":"MixedModels.isfullrank","text":"isfullrank(A::FeTerm)\n\nDoes A have full column rank?\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.kchoose2-Tuple{Any}","page":"API","title":"MixedModels.kchoose2","text":"kchoose2(k)\n\nThe binomial coefficient k choose 2 which is the number of elements in the packed form of the strict lower triangle of a matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.kp1choose2-Tuple{Any}","page":"API","title":"MixedModels.kp1choose2","text":"kp1choose2(k)\n\nThe binomial coefficient k+1 choose 2 which is the number of elements in the packed form of the lower triangle of a matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.likelihoodratiotest-Tuple{Union{GLM.GeneralizedLinearModel, GLM.LinearModel, MixedModel, StatsModels.TableRegressionModel{<:Union{GLM.GeneralizedLinearModel, GLM.LinearModel}}}, Vararg{MixedModel}}","page":"API","title":"MixedModels.likelihoodratiotest","text":"likelihoodratiotest(m::MixedModel...)\nlikelihoodratiotest(m0::LinearModel, m::MixedModel...)\nlikelihoodratiotest(m0::GeneralizedLinearModel, m::MixedModel...)\nlikelihoodratiotest(m0::TableRegressionModel{LinearModel}, m::MixedModel...)\nlikelihoodratiotest(m0::TableRegressionModel{GeneralizedLinearModel}, m::MixedModel...)\n\nLikeihood ratio test applied to a set of nested models.\n\nThis function is wrapper around StatsModels.lrtest that provides improved show methods that include the model formulae, where available. For mixed models, the isnested functionality may be overly conservative. For example, nested models with \"clever\" parameterizations may be incorrectly rejected as being non-negative. In such cases, it is incumbent on the user to perform the likelihood ratio test manually and construct the resulting LikelihoodRatioTest object.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.nranef-Tuple{ReMat}","page":"API","title":"MixedModels.nranef","text":"nranef(A::ReMat)\n\nReturn the number of random effects represented by A.  Zero unless A is an ReMat.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.nθ-Tuple{ReMat}","page":"API","title":"MixedModels.nθ","text":"nθ(A::ReMat)\n\nReturn the number of free parameters in the relative covariance matrix λ\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.opt_params","page":"API","title":"MixedModels.opt_params","text":"opt_params(::Val{backend})\n\nReturn a collection of the fields of OptSummary used by backend.\n\n:xtol_zero_abs, :ftol_zero_abs do not need to be specified because they are used after optimization and are thus shared across backends.\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedModels.optimize!","page":"API","title":"MixedModels.optimize!","text":"optimize!(::LinearMixedModel, ::Val{backend}; kwargs...)\noptimize!(::GeneralizedLinearMixedModel, ::Val{backend}; kwargs...)\n\nPerform optimization on a mixed model, minimizing the objective.\n\noptimize! set ups the call to the backend optimizer using the options contained in the model's optsum field. It then calls that optimizer and returns xmin, fmin. Providing support for a new backend involves defining appropriate optimize! methods with the second argument of type ::Val{:backend_name} and adding :backend_name to OPTIMIZATION_BACKENDS. Similarly, a method opt_params(::Val{:backend_name}) should be defined, which returns the optimization parameters (e.g. xtol_abs or rho_end) used by the backend.\n\nCommon keyword arguments are progress to show a progress meter as well as nAQG and fast for GLMMs.\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedModels.optimizers","page":"API","title":"MixedModels.optimizers","text":"optimizers(::Val{backend})\n\nReturn a collection of the algorithms supported by the backend.\n\nnote: Note\nThe names of the algorithms are not necessarily consistent across backends. For example, NLopt has :LN_BOBYQA and PRIMA has :bobyqa for Powell's BOBYQA algorithm. In other words, we have not yet abstracted over the backends' differing naming conventions for algorithms.\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedModels.optsumj-Tuple{OptSummary, Integer}","page":"API","title":"MixedModels.optsumj","text":"optsumj(os::OptSummary, j::Integer)\n\nReturn an OptSummary with the j'th component of the parameter omitted.\n\nos.final with its j'th component omitted is used as the initial parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.parsej-Tuple{Symbol}","page":"API","title":"MixedModels.parsej","text":"parsej(sym::Symbol)\n\nReturn the index from symbol names like :θ1, :θ01, etc.\n\nnote: Note\nThis method is internal.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.pivot-Tuple{MixedModel}","page":"API","title":"MixedModels.pivot","text":"pivot(m::MixedModel)\npivot(A::FeTerm)\n\nReturn the pivot associated with the FeTerm.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.profileσs!-Union{Tuple{T}, Tuple{NamedTuple, MixedModels.TableColumns{T}}} where T","page":"API","title":"MixedModels.profileσs!","text":" profileσs!(val::NamedTuple, tc::TableColumns{T}; nzlb=1.0e-8) where {T}\n\nProfile the variance components.\n\nnote: Note\nThis method is called by profile and currently considered internal. As such, it may change or disappear in a future release without being considered breaking.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.ranef!-Union{Tuple{T}, Tuple{Vector, LinearMixedModel{T}, AbstractArray{T}, Bool}} where T","page":"API","title":"MixedModels.ranef!","text":"ranef!(v::Vector{Matrix{T}}, m::MixedModel{T}, β, uscale::Bool) where {T}\n\nOverwrite v with the conditional modes of the random effects for m.\n\nIf uscale is true the random effects are on the spherical (i.e. u) scale, otherwise on the original scale\n\nβ is the truncated, pivoted coefficient vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.rankUpdate!","page":"API","title":"MixedModels.rankUpdate!","text":"rankUpdate!(C, A)\nrankUpdate!(C, A, α)\nrankUpdate!(C, A, α, β)\n\nA rank-k update, C := αA'A + βC, of a Hermitian (Symmetric) matrix.\n\nα and β both default to 1.0.  When α is -1.0 this is a downdate operation. The name rankUpdate! is borrowed from [https://github.com/andreasnoack/LinearAlgebra.jl]\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedModels.rePCA-Tuple{LinearMixedModel}","page":"API","title":"MixedModels.rePCA","text":"rePCA(m::LinearMixedModel; corr::Bool=true)\n\nReturn a named tuple of the normalized cumulative variance of a principal components analysis of the random effects covariance matrices or correlation matrices when corr is true.\n\nThe normalized cumulative variance is the proportion of the variance for the first principal component, the first two principal components, etc.  The last element is always 1.0 representing the complete proportion of the variance.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.rectify!-Tuple{LinearMixedModel}","page":"API","title":"MixedModels.rectify!","text":"rectify!(m::LinearMixedModel)\n\nFor each element of m.λ check for negative values on the diagonal and flip the signs of the entire column when any are present.\n\nThis provides a canonical converged value of θ.  We use unconstrained optimization followed by this reassignment to avoid the hassle of constrained optimization.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.reevaluateAend!-Tuple{LinearMixedModel}","page":"API","title":"MixedModels.reevaluateAend!","text":"reevaluateAend!(m::LinearMixedModel)\n\nReevaluate the last column of m.A from m.Xymat.  This function should be called after updating the response.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.refitσ!-Union{Tuple{T}, Tuple{LinearMixedModel{T}, Any, MixedModels.TableColumns{T}, T, Bool}} where T","page":"API","title":"MixedModels.refitσ!","text":"refitσ!(m::LinearMixedModel{T}, σ::T, tc::TableColumns{T}, obj::T, neg::Bool)\n\nRefit the model m with the given value of σ and return a NamedTuple of information about the fit.\n\nobj and neg allow for conversion of the objective to the ζ scale and tc is used to return a NamedTuple\n\nnote: Note\nThis method is internal and may change or disappear in a future release without being considered breaking.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.schematize","page":"API","title":"MixedModels.schematize","text":"schematize(f, tbl, contrasts::Dict{Symbol}, Mod=LinearMixedModel)\n\nFind and apply the schema for f in a way that automatically uses Grouping() contrasts when appropriate.\n\nwarning: Warning\nThis is an internal method.\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedModels.sdcorr-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"API","title":"MixedModels.sdcorr","text":"sdcorr(A::AbstractMatrix{T}) where {T}\n\nTransform a square matrix A with positive diagonals into an NTuple{size(A,1), T} of standard deviations and a tuple of correlations.\n\nA is assumed to be symmetric and only the lower triangle is used.  The order of the correlations is row-major ordering of the lower triangle (or, equivalently, column-major in the upper triangle).\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.setβθ!-Tuple{GeneralizedLinearMixedModel, Any}","page":"API","title":"MixedModels.setβθ!","text":"setβθ!(m::GeneralizedLinearMixedModel, v)\n\nSet the parameter vector, :βθ, of m to v.\n\nβθ is the concatenation of the fixed-effects, β, and the covariance parameter, θ.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.ssqdenom-Tuple{LinearMixedModel}","page":"API","title":"MixedModels.ssqdenom","text":"ssqdenom(m::LinearMixedModel)\n\nReturn the denominator for penalized sums-of-squares.\n\nFor MLE, this value is the number of observations. For REML, this value is the number of observations minus the rank of the fixed-effects matrix. The difference is analogous to the use of n or n-1 in the denominator when calculating the variance.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.statsrank-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"MixedModels.statsrank","text":"statsrank(x::Matrix{T}, ranktol::Real=1e-8) where {T<:AbstractFloat}\n\nReturn the numerical column rank and a pivot vector.\n\nThe rank is determined from the absolute values of the diagonal of R from a pivoted QR decomposition, relative to the first (and, hence, largest) element of this vector.\n\nIn the full-rank case the pivot vector is collect(axes(x, 2)).\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.tidyβ-Union{Tuple{MixedModels.MixedModelFitCollection{T}}, Tuple{T}} where T","page":"API","title":"MixedModels.tidyβ","text":"tidyβ(bsamp::MixedModelFitCollection)\n\nReturn a tidy (row)table with the parameter estimates spread into columns of iter, coefname and β\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.tidyσs-Union{Tuple{MixedModels.MixedModelFitCollection{T}}, Tuple{T}} where T","page":"API","title":"MixedModels.tidyσs","text":"tidyσs(bsamp::MixedModelFitCollection)\n\nReturn a tidy (row)table with the estimates of the variance components (on the standard deviation scale) spread into columns of iter, group, column and σ.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.unfit!-Union{Tuple{LinearMixedModel{T}}, Tuple{T}} where T","page":"API","title":"MixedModels.unfit!","text":"unfit!(model::MixedModel)\n\nMark a model as unfitted.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.unscaledre!","page":"API","title":"MixedModels.unscaledre!","text":"unscaledre!(y::AbstractVector{T}, M::ReMat{T}) where {T}\nunscaledre!(rng::AbstractRNG, y::AbstractVector{T}, M::ReMat{T}) where {T}\n\nAdd unscaled random effects simulated from M to y.\n\nThese are unscaled random effects (i.e. they incorporate λ but not σ) because the scaling is done after the per-observation noise is added as a standard normal.\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedModels.updateA!-Tuple{LinearMixedModel}","page":"API","title":"MixedModels.updateA!","text":"updateA!(m::LinearMixedModel)\n\nUpdate the cross-product array, m.A, from m.reterms and m.Xymat\n\nThis is usually done after a reweight! operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.updateη!-Union{Tuple{GeneralizedLinearMixedModel{T}}, Tuple{T}} where T","page":"API","title":"MixedModels.updateη!","text":"updateη!(m::GeneralizedLinearMixedModel)\n\nUpdate the linear predictor, m.η, from the offset and the B-scale random effects.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.σvals!-Tuple{AbstractVector, ReMat, Number}","page":"API","title":"MixedModels.σvals!","text":"σvals!(v::AbstractVector, A::ReMat, sc::Number)\n\nOverwrite v with the standard deviations of the random effects associated with A\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.σρ!-Union{Tuple{T}, Tuple{AbstractVector{<:Union{Missing, T}}, LinearAlgebra.LowerTriangular, Any}} where T","page":"API","title":"MixedModels.σρ!","text":"σρ!(v, t, σ)\n\npush! σ times the row lengths (σs) and the inner products of normalized rows (ρs) of t onto v\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsModels.isnested-Tuple{MixedModel, MixedModel}","page":"API","title":"StatsModels.isnested","text":"isnested(m1::MixedModel, m2::MixedModel; atol::Real=0.0)\n\nIndicate whether model m1 is nested in model m2, i.e. whether m1 can be obtained by constraining some parameters in m2. Both models must have been fitted on the same data. This check is conservative for MixedModels and may reject nested models with different parameterizations as being non nested.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsModels.isnested-Tuple{ReMat, ReMat}","page":"API","title":"StatsModels.isnested","text":"isnested(A::ReMat, B::ReMat)\n\nIs the grouping factor for A nested in the grouping factor for B?\n\nThat is, does each value of A occur with just one value of B?\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedModels.OPTIMIZATION_BACKENDS","page":"API","title":"MixedModels.OPTIMIZATION_BACKENDS","text":"OPTIMIZATION_BACKENDS\n\nA list of currently available optimization backends.\n\n\n\n\n\n","category":"constant"},{"location":"mime/#Alternative-display-and-output-formats","page":"Alternative display and output formats","title":"Alternative display and output formats","text":"In the documentation, we have presented the output from MixedModels.jl in the same format you will see when working in the REPL. You may have noticed, however, that output from other packages received pretty printing. For example, DataFrames are converted into nice HTML tables. In MixedModels.jl, we recently (v3.2.0) introduced limited support for such pretty printing. (For more details on how the print and display system in Julia works, check out this NextJournal post.)\n\nIn particular, we have defined Markdown, HTML and LaTeX output, i.e. show methods, for our types. Note that the Markdown output can also be easily and more flexibly translated into HTML, LaTeX (e.g. with booktabs) or even a MS Word Document using tools such as pandoc. Packages like IJulia and Documenter can often detect the presence of these display options and use them automatically.\n\nusing MixedModels, MixedModelsDatasets\nform = @formula(rt_trunc ~ 1 + spkr * prec * load +\n                          (1 + load | item) +\n                          (1 + spkr + prec + load | subj))\ncontr = Dict(:spkr => EffectsCoding(),\n             :prec => EffectsCoding(),\n             :load => EffectsCoding(),\n             :item => Grouping(),\n             :subj => Grouping())\nkbm = fit(MixedModel, form, MixedModelsDatasets.dataset(:kb07); contrasts=contr)\n\nNote that the display here is more succinct than the standard REPL display:\n\nusing DisplayAs\nkbm |> DisplayAs.Text\n\nThis brevity is intentional: we wanted these types to work well with traditional academic publishing constraints on tables. The summary for a model fit presented in the REPL does not mesh well with being treated as a single table (with columns shared between the random and fixed effects). In our experience, this leads to difficulties in typesetting the resulting tables. We nonetheless encourage users to report fit statistics such as the log likelihood or AIC as part of the caption of their table. If the correlation parameters in the random effects are of interest, then VarCorr can also be pretty printed:\n\nVarCorr(kbm)\n\nSimilarly for BlockDescription, OptSummary and MixedModels.likelihoodratiotest:\n\nBlockDescription(kbm)\n\nkbm.optsum\n\nm0 = fit(MixedModel, @formula(reaction ~ 1 + (1|subj)), MixedModelsDatasets.dataset(:sleepstudy))\nm1 = fit(MixedModel, @formula(reaction ~ 1 + days + (1+days|subj)), MixedModelsDatasets.dataset(:sleepstudy))\nMixedModels.likelihoodratiotest(m0,m1)\n\nTo explicitly invoke this behavior, we must specify the right show method. (The raw and not rendered output is intentionally shown here.)\n\nshow(MIME(\"text/markdown\"), m1)\n\nprintln(sprint(show, MIME(\"text/markdown\"), kbm)) # hide\n\nshow(MIME(\"text/html\"), m1)\n\nprintln(sprint(show, MIME(\"text/html\"), kbm)) # hide\n\nNote for that LaTeX, the column labels for the random effects are slightly changed: σ is placed into math mode and escaped and the grouping variable is turned into a subscript. Similarly for the likelihood ratio test, the χ² is escaped into math mode. This transformation improves pdfLaTeX and journal compatibility, but also means that XeLaTeX and LuaTeX may use a different font at this point.\n\nshow(MIME(\"text/latex\"), m1)\n\nprintln(sprint(show, MIME(\"text/latex\"), kbm)) # hide\n\nThis escaping behavior can be disabled by specifying \"text/xelatex\" as the MIME type. (Note that other symbols may still be escaped, as the internal conversion uses the Markdown module from the standard library, which performs some escaping on its own.)\n\nshow(MIME(\"text/xelatex\"), m1)\n\nprintln(sprint(show, MIME(\"text/xelatex\"), kbm)) # hide\n\nThis output can also be written directly to file:\n\nopen(\"model.md\", \"w\") do io\n    show(io, MIME(\"text/markdown\"), kbm)\nend","category":"section"},{"location":"rankdeficiency/#Rank-deficiency-in-mixed-effects-models","page":"Rank deficiency in mixed-effects models","title":"Rank deficiency in mixed-effects models","text":"The (column) rank of a matrix refers to the number of linearly independent columns in the matrix. Clearly, the rank can never be more than the number of columns; however, the rank can be less than the number of columns. In a regression context, this corresponds to a (linear) dependency in the predictors. The simplest case of rank deficiency is a duplicated predictor or a predictor that is exactly a multiple of another predictor. However, rank deficiency can also arise in more subtle ways, such as from missing cells in a two-factor experimental design. Rank deficiency can also arise as an extreme case of multicollinearity. In all cases, it is important to remember that we can only assess the numerical rank of a matrix, which may be less than its theoretical rank, and that evaluation of this numerical rank requires setting some numerical tolerance levels. These choices are not always well-defined. In other words, the rank of a matrix is well-defined in theory but in practice can be difficult to evaluate.\n\nRank deficiency can occur in two ways in mixed-effects models: in the fixed effects and in the random effects. The implications of rank deficiency and thus the handling of it differ between these.","category":"section"},{"location":"rankdeficiency/#Fixed-effects","page":"Rank deficiency in mixed-effects models","title":"Fixed effects","text":"The consequences of rank deficiency in the fixed effects are similar to those in classical ordinary least squares (OLS) regression. If one or more predictors can be expressed as a linear combination of the other columns, then this column is redundant and the model matrix is rank deficient. Note however, that the redundant column is not defined uniquely. For example, in the case that of two columns a and b where b = 2a, then the rank deficiency can be handled by eliminating either a or b. While we defined b here in terms of a, it may be that b is actually the more 'fundamental' predictor and hence we may define a in terms of b as a = 0.5b. The user may of course possess this information, but the choice is not apparent to the modelling software. As such, the handling of rank deficiency in MixedModels.jl should not be taken as a replacement for thinking about the nature of the predictors in a given model.\n\nThere is a widely accepted convention for how to make the coefficient estimates for these redundant columns well-defined: we set their value to zero and their standard errors to NaN (and thus also their z and p-values). The values that have been defined to be zero, as opposed to evaluating to zero, are displayed as -0.0 as an additional visual aid to distinguish them from the other coefficients. In practice the determination of rank and the redundant coefficients is done via a 'pivoting' scheme during a decomposition to move the surplus columns to the right side of the model matrix. In subsequent calculations, these columns are effectively ignored (as their estimates are zero and thus won't contribute to any other computations). For display purposes, this pivoting is unwound when the coef values are displayed.\n\nBoth the pivoted and unpivoted coefficients are available in MixedModels.jl. The fixef extractor returns the pivoted, truncated estimates (i.e. the non-redundant terms), while the coef extractor returns the unpivoted estimates (i.e. all terms, included the redundant ones). The same holds for the associated fixefnames and coefnames.","category":"section"},{"location":"rankdeficiency/#Pivoting-is-platform-dependent","page":"Rank deficiency in mixed-effects models","title":"Pivoting is platform dependent","text":"In MixedModels.jl, we use standard numerical techniques to detect rank deficiency. We currently offer no guarantees as to which exactly of the standard techniques (pivoted QR decomposition, pivoted Cholesky decomposition, etc.) will be used. This choice should be viewed as an implementation detail. Similarly, we offer no guarantees as to which of columns will be treated as redundant. This choice may vary between releases and even between platforms (both in broad strokes of \"Linux\" vs. \"Windows\" and at the level of which BLAS options are loaded on a given processor architecture) for the same release. In other words, you should not rely on the order of the pivoted columns being consistent! when you switch to a different computer or a different operating system. If consistency in the pivoted columns is important to you, then you should instead determine your rank ahead of time and remove extraneous columns / predictors from your model specification.\n\nThis lack of consistency guarantees arises from a more fundamental issue: numeric linear algebra is challenging and sensitive to the underlying floating point operations. Due to rounding error, floating point arithmetic is not associative:\n\n0.1 + 0.1 + 0.1 - 0.3 == 0.1 + 0.1 + (0.1 - 0.3)\n\nThis means that \"nearly\" / numerically rank deficient matrices may or may not be detected as rank deficient, depending on details of the platform. Determining the rank of a matrix is the type of problem that is well-defined in theory but not in practice.\n\nCurrently, a coarse heuristic is applied to reduce the chance that the intercept column will be pivoted, but even this behavior is not guaranteed.","category":"section"},{"location":"rankdeficiency/#Undetected-Rank-Deficiency","page":"Rank deficiency in mixed-effects models","title":"Undetected Rank Deficiency","text":"Undetected rank deficiency in the fixed effects will lead to numerical issues, such as nonsensical estimates. A PosDefException may indicate rank deficiency because the covariance matrix will only be positive semidefinite and not positive definite (see Details of the parameter estimation). In other words, checking that the fixed effects are full rank is a great first step in debugging a PosDefException.\n\nNote that PosDefException is not specific to rank deficiency and may arise in other ill-conditioned models. In any case, examining the model specification and the data to verify that they work together is the first step. For generalized linear mixed-effects models, it may also be worthwhile to try out fast=true instead of the default fast=false. See this GitHub issue and linked Discourse discussion for more information.","category":"section"},{"location":"rankdeficiency/#Random-effects","page":"Rank deficiency in mixed-effects models","title":"Random effects","text":"Rank deficiency presents less of a problem in the random effects than in the fixed effects because the \"estimates\" (more formally, the conditional modes of the random effects given the observed data) are determined as the solution to a penalized least squares problem. The shrinkage effect which moves the conditional modes (group-level predictions) towards the grand mean is a form of regularization, which provides well-defined \"estimates\" for overparameterized models. (For more reading on this general idea, see also this blog post on the model complexity myth.)\n\nThe nature of the penalty in the penalized least squares solution is such that the \"estimates\" are well-defined even when the covariance matrix of the random effects converges to a \"singular\" or \"boundary\" value. In other words, singularity of the covariance matrix for the random effects, which means that there are one or more directions in which there is no variability in the random effects, is different from singularity of the model matrix for the random effects, which would affect the ability to define uniquely these coefficients. The penalty term always provides a unique solution for the random-effects coefficients.\n\nIn addition to handling naturally occurring rank deficiency in the random effects, the regularization allows us to fit explicitly overparameterized random effects. For example, we can use fulldummy to fit both an intercept term and n indicator variables in the random effects for a categorical variable with n levels instead of the usual n-1 contrasts.\n\nkb07 = MixedModelsDatasets.dataset(:kb07)\ncontrasts = Dict(var => HelmertCoding() for var in (:spkr, :prec, :load))\nfit(MixedModel, @formula(rt_raw ~ spkr * prec * load + (1|subj) + (1+prec|item)), kb07; contrasts=contrasts)\nDisplayAs.Text(ans) # hide\n\nfit(MixedModel, @formula(rt_raw ~ spkr * prec * load + (1|subj) + (1+fulldummy(prec)|item)), kb07; contrasts=contrasts)\nDisplayAs.Text(ans) # hide\n\nThis may be useful when the PCA property suggests a random effects structure larger than only main effects but smaller than all interaction terms. This is also similar to the functionality provided by dummy in lme4, but as in the difference between zerocorr in Julia and || in R, there are subtle differences in how this expansion interacts with other terms in the random effects.","category":"section"},{"location":"prediction/#Prediction-and-simulation-in-Mixed-Effects-Models","page":"Prediction and simulation in Mixed-Effects Models","title":"Prediction and simulation in Mixed-Effects Models","text":"We recommend the MixedModelsSim.jl package and associated documentation for useful tools in constructing designs to simulate. For now, we'll use the sleep study data as a starting point.\n\nusing DataFrames\nusing MixedModels\nusing MixedModelsDatasets\nusing StatsBase\nusing DisplayAs # hide\n# use a DataFrame to make it easier to change things later\nslp = DataFrame(MixedModelsDatasets.dataset(:sleepstudy))\nslpm = fit(MixedModel, @formula(reaction ~ 1 + days + (1|subj)), slp)\nDisplayAs.Text(slpm) # hide","category":"section"},{"location":"prediction/#Prediction","page":"Prediction and simulation in Mixed-Effects Models","title":"Prediction","text":"The simplest form of prediction are the fitted values from the model: they are indeed the model's predictions for the observed data.\n\npredict(slpm) ≈ fitted(slpm)\n\nWhen generalizing to new data, we need to consider what happens if there are new, previously unobserved levels of the grouping variable(s). MixedModels.jl provides three options:\n\n:error: error on encountering unobserved levels\n:population: use population values (i.e. only the fixed effects) for observations with unobserved levels\n:missing: return missing for observations with unobserved levels.\n\nProviding either no prediction (:error, :missing) or providing the population-level values seem to be the most reasonable ways for predicting new values. For simulating new values based on previous estimates of the variance components, use simulate.\n\nIn the case where there are no new levels of the grouping variable, all three of these methods provide the same results:\n\npredict(slpm, slp; new_re_levels=:population) ≈ fitted(slpm)\n\npredict(slpm, slp; new_re_levels=:missing) ≈ fitted(slpm)\n\npredict(slpm, slp; new_re_levels=:error) ≈ fitted(slpm)\n\nIn the case where there are new levels of the grouping variable, these methods differ.\n\n# create a new level\nslp2 = transform(slp, :subj => ByRow(x -> (x == \"S308\" ? \"NEW\" : x)) => :subj)\nDisplayAs.Text(ans) # hide\n\ntry\n  predict(slpm, slp2; new_re_levels=:error)\ncatch e\n  show(e)\nend\n\npredict(slpm, slp2; new_re_levels=:missing)\n\npredict(slpm, slp2; new_re_levels=:population)\n\nnote: Note\nCurrently, we do not support predicting based on a subset of the random effects.\n\nnote: Note\npredict is deterministic (within the constraints of floating point) and never adds noise to the result. If you want to construct prediction intervals, then simulate will generate new data with noise (including new values of the random effects).\n\nFor generalized linear mixed models, there is an additional keyword argument to predict: type specifies whether the predictions are returned on the scale of the linear predictor (:linpred) or on the level of the response (:response) (i.e. the level at which the values were originally observed).\n\ncbpp = DataFrame(MixedModelsDatasets.dataset(:cbpp))\ncbpp.rate = cbpp.incid ./ cbpp.hsz\ngm = fit(MixedModel, @formula(rate ~ 1 + period + (1|herd)), cbpp, Binomial(), wts=float(cbpp.hsz))\npredict(gm, cbpp; type=:response) ≈ fitted(gm)\n\nlogit(x) = log(x / (1 - x))\npredict(gm, cbpp; type=:linpred) ≈ logit.(fitted(gm))","category":"section"},{"location":"prediction/#Simulation","page":"Prediction and simulation in Mixed-Effects Models","title":"Simulation","text":"In contrast to predict, simulate and simulate! introduce randomness. This randomness occurs both at the level of the observation-level (residual) variance and at the level of the random effects, where new conditional modes are sampled based on the specified covariance parameter (θ; see Details of the parameter estimation), which defaults to the estimated value of the model. For reproducibility, we specify a pseudorandom generator here; if none is provided, the global PRNG is taken as the default.\n\nThe simplest example of simulate takes a fitted model and generates a new response vector based on the existing model matrices combined with noise.\n\nusing Random\nynew = simulate(MersenneTwister(42), slpm)\n\nThe simulated response can also be placed in a pre-allocated vector:\n\nynew2 = zeros(nrow(slp))\nsimulate!(MersenneTwister(42), ynew2, slpm)\nynew2 ≈ ynew\n\nOr even directly replace the previous response vector in a model, at which point the model must be refit to the new values:\n\nslpm2 = deepcopy(slpm)\nrefit!(simulate!(MersenneTwister(42), slpm2))\nDisplayAs.Text(ans) # hide\n\nThis inplace simulation actually forms the basis of parametricbootstrap.\n\nFinally, we can also simulate the response from entirely new data.\n\ndf = DataFrame(days = repeat(1:10, outer=20), subj=repeat(1:20, inner=10))\ndf[!, :subj] = string.(\"S\", lpad.(df.subj, 2, \"0\"))\ndf[!, :reaction] .= 0\ndf\nDisplayAs.Text(df) # hide\n\nysim = simulate(MersenneTwister(42), slpm, df)\n\nNote that this is a convenience method for creating a new model and then using the parameters from the old model to call simulate on that model. In other words, this method incurs the cost of constructing a new model and then discarding it. If you could re-use that model (e.g., fitting that model as part of a simulation study), it often makes sense to do these steps to perform these steps explicitly and avoid the unnecessary construction and discarding of an intermediate model:\n\nmsim = LinearMixedModel(@formula(reaction ~ 1 + days + (1|subj)), df)\nsimulate!(MersenneTwister(42), msim; θ=slpm.θ, β=slpm.β, σ=slpm.σ)\nresponse(msim) ≈ ysim\n\nfit!(msim)\nDisplayAs.Text(ans) # hide\n\nFor simulating from generalized linear mixed models, there is no type option because the observation-level always occurs at the level of the response and not of the linear predictor.\n\nwarning: Warning\nSimulating the model response in place may not yield the same result as simulating into a pre-allocated or new vector, depending on choice of pseudorandom number generator. Random number generation in Julia allows optimization based on type, and the internal storage type of the model response (currently a view into a matrix storing the concatenated fixed-effects model matrix and the response) may not match the type of a pre-allocated or new vector. See also discussion here.\n\nnote: Note\nAll the methods that take new data as a table construct an additional MixedModel behind the scenes, even when the new data is exactly the same as the data that the model was fitted to. For the simulation methods in particular, these thus form a convenience wrapper for constructing a new model and calling simulate without new data on that model with the parameters from the original model.","category":"section"},{"location":"#MixedModels.jl-Documentation","page":"MixedModels.jl Documentation","title":"MixedModels.jl Documentation","text":"MixedModels.jl is a Julia package providing capabilities for fitting and examining linear and generalized linear mixed-effect models. It is similar in scope to the lme4 package for R.","category":"section"},{"location":"#Quick-Start","page":"MixedModels.jl Documentation","title":"Quick Start","text":"You can fit a model using a lmer-style model formula using @formula and a dataset. Here is a short example of how to fit a linear mixed-effects modeling using the dyestuff dataset:\n\nusing DataFrames, MixedModels, MixedModelsDatasets  # load packages\ndyestuff = MixedModelsDatasets.dataset(:dyestuff);   # load dataset\n\nlmod = lmm(@formula(yield ~ 1 + (1|batch)), dyestuff)   # fit the model!\nDisplayAs.Text(ans) # hide\n\nFor a generalized linear mixed-effect model, you have to specify a distribution for the response variable (and optionally a link function). A quick example of generalized linear model using the verbagg dataset:\n\nusing DataFrames, MixedModels               # load packages\nverbagg = MixedModelsDatasets.dataset(:verbagg);    # load dataset\n\nfrm = @formula(r2 ~ 1 + anger + gender + btype + situ + mode + (1|subj) + (1|item));\nbernmod = glmm(frm, verbagg, Bernoulli())   # fit the model!\nDisplayAs.Text(ans) # hide","category":"section"},{"location":"#Contents","page":"MixedModels.jl Documentation","title":"Contents","text":"Pages = [\n        \"constructors.md\",\n        \"optimization.md\",\n        \"GaussHermite.md\",\n        \"bootstrap.md\",\n        \"rankdeficiency.md\",\n        \"mime.md\",\n]\nDepth = 2","category":"section"}]
}
